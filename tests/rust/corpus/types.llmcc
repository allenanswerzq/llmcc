===============================================================================
the-unit-type
===============================================================================


--- file: src/main.rs ---
type A = ();

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         
u0:3 | Type   | A    | A    |         


===============================================================================
tuple-types
===============================================================================


--- file: src/main.rs ---
type A = (i32, String);

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         
u0:3 | Type   | A    | A    |         


===============================================================================
reference-types
===============================================================================


--- file: src/main.rs ---
type A = &B;
type C = &'a str;
type D = &'a mut str;

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         
u0:3 | Type   | A    | A    |         
u0:4 | Type   | C    | C    |         
u0:5 | Type   | D    | D    |         


===============================================================================
raw-pointer-types
===============================================================================


--- file: src/main.rs ---
type A = *mut B;
type C = *const str;

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         
u0:3 | Type   | A    | A    |         
u0:4 | Type   | C    | C    |         


===============================================================================
generic-types
===============================================================================


--- file: src/main.rs ---
type A = B<C>;
type D = E<F, str>;
type G = H<'a, I>;
type J = H<K=L>;

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         
u0:3 | Type   | A    | A    |         
u0:4 | Type   | D    | D    |         
u0:5 | Type   | G    | G    |         
u0:6 | Type   | J    | J    |         


===============================================================================
scoped-types
===============================================================================


--- file: src/main.rs ---
type A = B::C;
type D = E::F::G;
type H = I::J<K>;
type L = M<N>::O;

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         
u0:3 | Type   | A    | A    |         
u0:4 | Type   | D    | D    |         
u0:5 | Type   | H    | H    |         
u0:6 | Type   | L    | L    |         


===============================================================================
array-types
===============================================================================


--- file: src/main.rs ---
type A = [B; 4];
type C = &[D];

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         
u0:3 | Type   | A    | A    |         
u0:4 | Type   | C    | C    |         


===============================================================================
function-types
===============================================================================


--- file: src/main.rs ---
fn high_order1(value: i32, f: fn(i32)) -> i32 {}

fn high_order2(value: i32, f: fn(i32) -> i32) -> i32 {
    f(value)
}

fn high_order3(value: i32, f: &FnOnce(i32) -> i32) -> i32 {
    f(value)
}

type F = for<'a, 'b> fn(x: &'a A, y: &'a mut B<'i, 't>,) -> C;

--- expect:symbols ---
u0:1  | Module   | main        | main        | [global]
u0:2  | File     | main        | main        |         
u0:3  | Function | high_order1 | high_order1 |         
u0:4  | Variable | value       | value       |         
u0:5  | Variable | f           | f           |         
u0:6  | Function | high_order2 | high_order2 |         
u0:7  | Variable | value       | value       |         
u0:8  | Variable | f           | f           |         
u0:9  | Function | high_order3 | high_order3 |         
u0:10 | Variable | value       | value       |         
u0:11 | Variable | f           | f           |         
u0:12 | Type     | F           | F           |         
u0:13 | Variable | x           | x           |         
u0:14 | Variable | y           | y           |         


===============================================================================
unsafe-and-extern-function-types
===============================================================================


--- file: src/main.rs ---
type a = extern "C" fn(*mut c_void);
type b = unsafe extern "C" fn() -> *mut c_void;

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         
u0:3 | Type   | a    | a    |         
u0:4 | Type   | b    | b    |         


===============================================================================
trait-objects
===============================================================================


--- file: src/main.rs ---
type a = Box<Something + 'a>;
type b = Rc<dyn Something>;
type c = A<&dyn Fn(&B) -> C>;

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         
u0:3 | Type   | a    | a    |         
u0:4 | Type   | b    | b    |         
u0:5 | Type   | c    | c    |         


===============================================================================
type-cast-expressions-with-generics
===============================================================================


--- file: src/main.rs ---
a as B<C>;
d as *mut E<<F as E>::G>;

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         

