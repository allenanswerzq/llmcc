===============================================================================
tuple-struct-patterns
===============================================================================


--- file: src/main.rs ---
enum E {
  V1(i32, String),
  V2,
}

fn foo() {
  let x = E::V1(10, "hello".to_string());
  match x {
    E::V1(a, b) => "v1",
    E::V2 => "v2",
  }
}

--- expect:symbols ---
u0:1 | Module      | main            | main                           | [global]
u0:2 | File        | main            | main::main                     |         
u0:3 | Enum        | E               | main::main::E                  |         
u0:4 | EnumVariant | V1(i32, String) | main::main::E::V1(i32, String) |         
u0:5 | EnumVariant | V2              | main::main::E::V2              |         
u0:6 | Function    | foo             | main::main::foo                |         
u0:7 | Variable    | x               | main::main::foo::x             |         

--- expect:symbol-deps ---


===============================================================================
reference-patterns
===============================================================================


--- file: src/main.rs ---
match x {
  A(ref x) => x.0,
  ref mut y => y,
  & mut  z => z,
}

--- expect:symbols ---
u0:1 | Module | main | main       | [global]
u0:2 | File   | main | main::main |         


===============================================================================
struct-patterns
===============================================================================


--- file: src/main.rs ---
match x {
  Person{name, age} if age < 5 => ("toddler", name),
  Person{name: adult_name, age: _} => ("adult", adult_name),
}

match y {
  Bar::T1(_, Some::<isize>(x)) => println!("{x}"),
}

--- expect:symbols ---
u0:1 | Module | main | main       | [global]
u0:2 | File   | main | main::main |         


===============================================================================
ignored-patterns
===============================================================================


--- file: src/main.rs ---
match x {
  (a, ..) => a,
  B(..) => c,
  D::E{f: g, ..} => g
}

--- expect:symbols ---
u0:1 | Module | main | main       | [global]
u0:2 | File   | main | main::main |         


===============================================================================
captured-patterns
===============================================================================


--- file: src/main.rs ---
match x {
  a @ A(_) | b @ B(..) => a,
  a @ 1 ... 5 => a,
  Some(1 ... 5) => a,
  a @ b...c => a,
  a @ b..=c => a,
  d.. => a,
  ..d => d,
  a @ ..=5 => a
}

match name {
  | "IPV6_FLOWINFO"
  | "IPV6_FLOWLABEL_MGR"
  | "IPV6_FLOWINFO_SEND" => true,
  _ => false,
}


===============================================================================
or-patterns
===============================================================================


--- file: src/main.rs ---
struct Bar;
struct Foo;
struct Slice;
impl Slice {
    fn binary_search(&self, x: &i32) -> Option<Foo> {
      Some(Foo)
    }
}

fn func_1() {
  if let A(x) | B(x) = Bar::new() {
      do_stuff_with(x);
  }

  while let A(x) | B(x) = expr {
      do_stuff_with(x);
  }
  
  let slice = Slice::new();
  let f = slice.binary_search(&x);

  for ref a | b in c {}

  let Ok(x) | Err(x) = binary_search(x);

  for A | B | C in c {}

  |(Ok(x) | Err(x))| expr();

  let ref mut x @ (A | B | C);
}

fn func_2((1 | 2 | 3): u8) {}

if let x!() | y!() = () {}

--- expect:symbols ---
u0:1  | Module   | main          | main                                | [global]
u0:2  | File     | main          | main::main                          |         
u0:3  | Struct   | Bar           | main::main::Bar                     |         
u0:4  | Struct   | Foo           | main::main::Foo                     |         
u0:5  | Impl     | Slice         | main::main::Slice                   |         
u0:6  | Function | binary_search | main::main::Slice::binary_search    |         
u0:7  | Variable | x             | main::main::Slice::binary_search::x |         
u0:8  | Function | func_1        | main::main::func_1                  |         
u0:9  | Variable | slice         | main::main::func_1::slice           |         
u0:10 | Variable | f             | main::main::func_1::f               |         
u0:11 | Variable | Ok            | main::main::func_1::Ok              |         
u0:12 | Variable | x             | main::main::func_1::x               |         
u0:13 | Function | func_2        | main::main::func_2                  |         

--- expect:symbol-deps ---
u0:4 <- [u0:6]
u0:6 -> [u0:4]
u0:6 <- [u0:8]
u0:8 -> [u0:6]


===============================================================================
inline-const-or-const-blocks-as-pattern
===============================================================================


--- file: src/main.rs ---
fn foo(x: i32) {
    const CUBE: i32 = 3.pow(3);
    match x {
        CUBE => println!("three cubed"),
        _ => {}
    }
}

fn foo(x: i32) {
    match x {
        const { 3.pow(3) } => println!("three cubed"),
        _ => {}
    }
}

--- expect:symbols ---
u0:1 | Module   | main | main                  | [global]
u0:2 | File     | main | main::main            |         
u0:3 | Function | foo  | main::main::foo       |         
u0:4 | Variable | x    | main::main::foo::x    |         
u0:5 | Const    | CUBE | main::main::foo::CUBE |         
u0:6 | Variable | x    | main::main::foo::x    |         


===============================================================================
pattern-with-turbofish
===============================================================================


--- file: src/main.rs ---
match y {
    None::<T> => 17,
    _ => 42,
}

--- expect:symbols ---
u0:1 | Module | main | main       | [global]
u0:2 | File   | main | main::main |         
