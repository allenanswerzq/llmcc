===============================================================================
modules
===============================================================================


--- file: src/main.rs ---
mod english;

mod english {}

mod english {
    mod greetings {}
    mod farewells {}
}

pub mod english;

--- expect:symbols ---
u0:1 | Module    | main      | main                           | [global]
u0:2 | File      | main      | main::main                     |         
u0:3 | Namespace | english   | main::main::english            |         
u0:4 | Namespace | greetings | main::main::english::greetings |         
u0:5 | Namespace | farewells | main::main::english::farewells |         


===============================================================================
extern-crate-declarations
===============================================================================


--- file: src/main.rs ---
extern crate std;
extern crate std as ruststd;
pub extern crate futures;

--- expect:symbols ---
u0:1 | Module | main | main       | [global]
u0:2 | File   | main | main::main |         


===============================================================================
function-declarations
===============================================================================


--- file: src/main.rs ---
fn main() {}

fn add(x: i32, y: i32) -> i32 {
    return x + y;
}

fn takes_slice(slice: &str) {
    println!("Got: {}", slice);
}

fn foo() -> [u32; 2] {
    return [1, 2];
}

fn foo() -> (u32, u16) {
    return (1, 2);
}

fn foo() {
    return
}

fn foo(x: impl FnOnce() -> result::Result<T, E>) {}

fn foo(#[attr] x: i32, #[attr] x: i64) {}

fn accumulate(self) -> Machine<{State::Accumulate}> {}

fn foo(bar: impl for<'a> Baz<Quux<'a>>) {}

--- expect:symbols ---
u0:1  | Module   | main        | main                           | [global]
u0:2  | File     | main        | main::main                     |         
u0:3  | Function | main        | main::main::main               |         
u0:4  | Function | add         | main::main::add                |         
u0:5  | Variable | x           | main::main::add::x             |         
u0:6  | Variable | y           | main::main::add::y             |         
u0:7  | Function | takes_slice | main::main::takes_slice        |         
u0:8  | Variable | slice       | main::main::takes_slice::slice |         
u0:9  | Function | foo         | main::main::foo                |         
u0:10 | Variable | x           | main::main::foo::x             |         
u0:11 | Variable | x           | main::main::foo::x             |         
u0:12 | Function | accumulate  | main::main::accumulate         |         
u0:13 | Variable | bar         | main::main::foo::bar           |         


===============================================================================
const-function-declarations
===============================================================================


--- file: src/main.rs ---
const fn main() {}

--- expect:symbols ---
u0:1 | Module   | main | main             | [global]
u0:2 | File     | main | main::main       |         
u0:3 | Function | main | main::main::main |         


===============================================================================
functions-with-abstract-return-types
===============================================================================


--- file: src/main.rs ---
trait B {}

struct Foo;

fn triples(a: impl B) -> impl Iterator<Item=(Foo)> {
}

--- expect:symbols ---
u0:1 | Module   | main    | main                   | [global]
u0:2 | File     | main    | main::main             |         
u0:3 | Trait    | B       | main::main::B          |         
u0:4 | Struct   | Foo     | main::main::Foo        |         
u0:5 | Function | triples | main::main::triples    |         
u0:6 | Variable | a       | main::main::triples::a |         

--- expect:symbol-deps ---
u0:3 <- [u0:5, u0:6]
u0:4 <- [u0:5]
u0:5 -> [u0:3, u0:4]
u0:6 -> [u0:3]


===============================================================================
impl-with-lifetimes-first
===============================================================================


--- file: src/main.rs ---
fn foo<'a>(x: impl 'a + Clone) {}

--- expect:symbols ---
u0:1 | Module   | main | main               | [global]
u0:2 | File     | main | main::main         |         
u0:3 | Function | foo  | main::main::foo    |         
u0:4 | Variable | x    | main::main::foo::x |         


===============================================================================
functions-with-precise-capture-syntax
===============================================================================


--- file: src/main.rs ---
fn capture<T>(&self) -> impl Iterator<Item = usize> + use<'_, T> {
}

--- expect:symbols ---
u0:1 | Module   | main    | main                   | [global]
u0:2 | File     | main    | main::main             |         
u0:3 | Function | capture | main::main::capture    |         
u0:4 | Type     | T       | main::main::capture::T |         


===============================================================================
functions-with-empty-precise-capture-syntax
===============================================================================


--- file: src/main.rs ---
fn capture(&self) -> impl Iterator<Item = usize> + use<> {
}

--- expect:symbols ---
u0:1 | Module   | main    | main                | [global]
u0:2 | File     | main    | main::main          |         
u0:3 | Function | capture | main::main::capture |         


===============================================================================
diverging-functions
===============================================================================


--- file: src/main.rs ---
fn aborts() -> ! {}

--- expect:symbols ---
u0:1 | Module   | main   | main               | [global]
u0:2 | File     | main   | main::main         |         
u0:3 | Function | aborts | main::main::aborts |         


===============================================================================
extern-function-declarations
===============================================================================


--- file: src/main.rs ---
extern "C" fn foo() {}
extern "C" fn printf(*const c_char, ...,) {}

pub unsafe extern "C" fn c_variadic_no_use(fmt: *const i8, mut ap: ...) -> i32 {
    // CHECK: call void @llvm.va_start
    vprintf(fmt, ap.as_va_list())
    // CHECK: call void @llvm.va_end
}

--- expect:symbols ---
u0:1 | Module   | main              | main                               | [global]
u0:2 | File     | main              | main::main                         |         
u0:3 | Function | foo               | main::main::foo                    |         
u0:4 | Function | printf            | main::main::printf                 |         
u0:5 | Function | c_variadic_no_use | main::main::c_variadic_no_use      |         
u0:6 | Variable | fmt               | main::main::c_variadic_no_use::fmt |         


===============================================================================
use-declarations
===============================================================================


--- file: src/main.rs ---
use abc;
use phrases::japanese;
use sayings::english::greetings;
use sayings::english::greetings as en_greetings ;
use phrases::english::{greetings,farewells};
use sayings::japanese::farewells::*;
pub use self::greetings::hello;
use sayings::english::{self, greetings as en_greetings, farewells as en_farewells};
use three::{ dot::{one, four} };
use my::{ some::* };
use my::{*};
use ::*;

--- expect:symbols ---
u0:1 | Module | main | main       | [global]
u0:2 | File   | main | main::main |         


===============================================================================
variable-bindings
===============================================================================


--- file: src/main.rs ---
let x;
let x = 42;
let x: i32;
let x: i8 = 42;
let mut x = 5;
let y: bool = false;
let bool: bool = false;
let u32: str = "";

--- expect:symbols ---
u0:1  | Module   | main | main             | [global]
u0:2  | File     | main | main::main       |         
u0:3  | Variable | x    | main::main::x    |         
u0:4  | Variable | x    | main::main::x    |         
u0:5  | Variable | x    | main::main::x    |         
u0:6  | Variable | x    | main::main::x    |         
u0:7  | Variable | x    | main::main::x    |         
u0:8  | Variable | y    | main::main::y    |         
u0:9  | Variable | bool | main::main::bool |         
u0:10 | Variable | u32  | main::main::u32  |         


===============================================================================
function-variable-bindings
===============================================================================


--- file: src/main.rs ---
struct Baz;
struct Foo;

fn func() {
    let x: Foo = Foo::new();
    let mut y = Baz::new();
}

--- expect:symbols ---
u0:1 | Module   | main | main                | [global]
u0:2 | File     | main | main::main          |         
u0:3 | Struct   | Baz  | main::main::Baz     |         
u0:4 | Struct   | Foo  | main::main::Foo     |         
u0:5 | Function | func | main::main::func    |         
u0:6 | Variable | x    | main::main::func::x |         
u0:7 | Variable | y    | main::main::func::y |         

--- expect:symbol-deps ---
u0:4 <- [u0:5, u0:6]
u0:5 -> [u0:4]
u0:6 -> [u0:4]


===============================================================================
let-else-statements
===============================================================================


--- file: src/main.rs ---
mod Foo {
    struct Bar;
}
struct Baz;

fn func() {
    let y = Baz::new();
    let Foo::Bar {
        texts,
        values,
    } = foo().bar().await? else {
        return Err(index)
    };

    let Some(x) = y else {
        let None = z else {
            foo();
            break;
        };
        continue;
    };
}

--- expect:symbols ---
u0:1  | Module    | main | main                   | [global]
u0:2  | File      | main | main::main             |         
u0:3  | Namespace | Foo  | main::main::Foo        |         
u0:4  | Struct    | Bar  | main::main::Foo::Bar   |         
u0:5  | Struct    | Baz  | main::main::Baz        |         
u0:6  | Function  | func | main::main::func       |         
u0:7  | Variable  | y    | main::main::func::y    |         
u0:8  | Variable  | Foo  | main::main::func::Foo  |         
u0:9  | Variable  | Some | main::main::func::Some |         
u0:10 | Variable  | None | main::main::func::None |         

--- expect:symbol-deps ---


===============================================================================
let-declarations-with-if-expressions-as-the-value
===============================================================================


--- file: src/main.rs ---
let a = if b {
    c
} else {
    d
};

--- expect:symbols ---
u0:1 | Module   | main | main          | [global]
u0:2 | File     | main | main::main    |         
u0:3 | Variable | a    | main::main::a |         


===============================================================================
let-declarations-with-contextual-keywords-as-names
===============================================================================


--- file: src/main.rs ---
let default = 1;
let union = 2;

--- expect:symbols ---
u0:1 | Module   | main    | main                | [global]
u0:2 | File     | main    | main::main          |         
u0:3 | Variable | default | main::main::default |         
u0:4 | Variable | union   | main::main::union   |         


===============================================================================
structs
===============================================================================


--- file: src/main.rs ---
struct Proton;
struct Electron {}
struct Person {pub name: String, pub age: u32}
struct Point {
  x: i32,

  #[attribute1]
  y: i32,
}
struct Color(pub i32, i32, i32);
struct Inches(i32);
struct Empty(pub ());

--- expect:symbols ---
u0:1  | Module | main     | main                     | [global]
u0:2  | File   | main     | main::main               |         
u0:3  | Struct | Proton   | main::main::Proton       |         
u0:4  | Struct | Electron | main::main::Electron     |         
u0:5  | Struct | Person   | main::main::Person       |         
u0:6  | Field  | name     | main::main::Person::name |         
u0:7  | Field  | age      | main::main::Person::age  |         
u0:8  | Struct | Point    | main::main::Point        |         
u0:9  | Field  | x        | main::main::Point::x     |         
u0:10 | Field  | y        | main::main::Point::y     |         
u0:11 | Struct | Color    | main::main::Color        |         
u0:12 | Struct | Inches   | main::main::Inches       |         
u0:13 | Struct | Empty    | main::main::Empty        |         


===============================================================================
unions
===============================================================================


--- file: src/main.rs ---
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
    _bindgen_union_align: [u32; 4usize],
}

--- expect:symbols ---
u0:1 | Module | main                 | main                             | [global]
u0:2 | File   | main                 | main::main                       |         
u0:3 | Field  | __u6_addr8           | main::main::__u6_addr8           |         
u0:4 | Field  | __u6_addr16          | main::main::__u6_addr16          |         
u0:5 | Field  | __u6_addr32          | main::main::__u6_addr32          |         
u0:6 | Field  | _bindgen_union_align | main::main::_bindgen_union_align |         


===============================================================================
generic-structs
===============================================================================


--- file: src/main.rs ---
struct A<B> {}
struct C<'a, 'b> {}
struct C<'a,> {}
struct D<const SIZE: usize> {}
struct E<#[attr] T> {}

--- expect:symbols ---
u0:1 | Module | main | main             | [global]
u0:2 | File   | main | main::main       |         
u0:3 | Struct | A    | main::main::A    |         
u0:4 | Type   | B    | main::main::A::B |         
u0:5 | Struct | C    | main::main::C    |         
u0:6 | Struct | D    | main::main::D    |         
u0:7 | Struct | E    | main::main::E    |         
u0:8 | Type   | T    | main::main::E::T |         


===============================================================================
enums-basic
===============================================================================


--- file: src/main.rs ---
struct Tree;

pub enum Option<T> {
    None,
    Some(T),
}

pub enum Node<T: Item> {
    Internal {
        children: Vec<Tree<T>>,
        height: u16
    },
    #[attribute1]
    #[attribute2]
    Leaf {
        value: T
    }
}

--- expect:symbols ---
u0:1  | Module      | main                                                                 | main                                                                                   | [global]
u0:2  | File        | main                                                                 | main::main                                                                             |         
u0:3  | Struct      | Tree                                                                 | main::main::Tree                                                                       |         
u0:4  | Enum        | Option                                                               | main::main::Option                                                                     |         
u0:5  | Type        | T                                                                    | main::main::Option::T                                                                  |         
u0:6  | EnumVariant | None                                                                 | main::main::Option::None                                                               |         
u0:7  | EnumVariant | Some(T)                                                              | main::main::Option::Some(T)                                                            |         
u0:8  | Enum        | Node                                                                 | main::main::Node                                                                       |         
u0:9  | Type        | T                                                                    | main::main::Node::T                                                                    |         
u0:10 | EnumVariant | Internal {
        children: Vec<Tree<T>>,
        height: u16
    } | main::main::Node::Internal {
        children: Vec<Tree<T>>,
        height: u16
    } |         
u0:11 | Field       | children                                                             | main::main::Node::children                                                             |         
u0:12 | Field       | height                                                               | main::main::Node::height                                                               |         
u0:13 | EnumVariant | Leaf {
        value: T
    }                                        | main::main::Node::Leaf {
        value: T
    }                                        |         
u0:14 | Field       | value                                                                | main::main::Node::value                                                                |         

--- expect:symbol-deps ---
u0:10 -> [u0:11, u0:12, u0:3, u0:9]
u0:11 -> [u0:3, u0:9]
u0:11 <- [u0:10, u0:8]
u0:12 <- [u0:10, u0:8]
u0:13 -> [u0:14, u0:9]
u0:14 -> [u0:9]
u0:14 <- [u0:13, u0:8]
u0:3 <- [u0:10, u0:11, u0:8]
u0:4 -> [u0:5]
u0:5 <- [u0:4, u0:7]
u0:7 -> [u0:5]
u0:8 -> [u0:11, u0:12, u0:14, u0:3, u0:9]
u0:9 <- [u0:10, u0:11, u0:13, u0:14, u0:8]

--- expect:blocks ---
u0:1 | root  | main   
u0:2 | class | Tree   
u0:3 | enum  | Option 
u0:4 | enum  | Node   
u0:5 | field | block#5
u0:6 | field | block#6
u0:7 | field | block#7

--- expect:block-deps ---
u0:2 <- [u0:4]
u0:4 -> [u0:2]


===============================================================================
enums-with-values-specified
===============================================================================


--- file: src/main.rs ---
pub enum c_style_enum {
    val1 = 1,
    val2 = 2
}

--- expect:symbols ---
u0:1 | Module      | main         | main                               | [global]
u0:2 | File        | main         | main::main                         |         
u0:3 | Enum        | c_style_enum | main::main::c_style_enum           |         
u0:4 | EnumVariant | val1 = 1     | main::main::c_style_enum::val1 = 1 |         
u0:5 | EnumVariant | val2 = 2     | main::main::c_style_enum::val2 = 2 |         


===============================================================================
generic-functions-one
===============================================================================


--- file: src/main.rs ---
struct Text;

pub fn splice<T: Into<Text>>(&mut self, old_range: Range<usize>, new_text: T) {
}
pub fn uninit_array<const LEN: usize>() -> [Self; LEN] {}

--- expect:symbols ---
u0:1 | Module   | main         | main                          | [global]
u0:2 | File     | main         | main::main                    |         
u0:3 | Struct   | Text         | main::main::Text              |         
u0:4 | Function | splice       | main::main::splice            |         
u0:5 | Type     | T            | main::main::splice::T         |         
u0:6 | Variable | old_range    | main::main::splice::old_range |         
u0:7 | Variable | new_text     | main::main::splice::new_text  |         
u0:8 | Function | uninit_array | main::main::uninit_array      |         

--- expect:symbol-deps ---
u0:4 -> [u0:5]
u0:5 <- [u0:4, u0:7]
u0:7 -> [u0:5]

--- expect:blocks ---
u0:1 | root  | main        
u0:2 | class | Text        
u0:3 | func  | splice      
u0:4 | func  | uninit_array

--- expect:block-deps ---


===============================================================================
functions-with-mutable-parameters
===============================================================================


--- file: src/main.rs ---
fn foo(mut x : u32) {
}

--- expect:symbols ---
u0:1 | Module   | main | main               | [global]
u0:2 | File     | main | main::main         |         
u0:3 | Function | foo  | main::main::foo    |         
u0:4 | Variable | x    | main::main::foo::x |         


===============================================================================
functions-with-destructured-parameters
===============================================================================


--- file: src/main.rs ---
struct Foo;
struct Y;
struct T;
struct U;

fn f1([x, y]: [Foo; 2]) {}

fn f2(&x: &Y) {}

fn f3((x, y): (T, U)) {}

--- expect:symbols ---
u0:1  | Module   | main | main              | [global]
u0:2  | File     | main | main::main        |         
u0:3  | Struct   | Foo  | main::main::Foo   |         
u0:4  | Struct   | Y    | main::main::Y     |         
u0:5  | Struct   | T    | main::main::T     |         
u0:6  | Struct   | U    | main::main::U     |         
u0:7  | Function | f1   | main::main::f1    |         
u0:8  | Variable | x    | main::main::f1::x |         
u0:9  | Function | f2   | main::main::f2    |         
u0:10 | Variable | x    | main::main::f2::x |         
u0:11 | Function | f3   | main::main::f3    |         
u0:12 | Variable | x    | main::main::f3::x |         

--- expect:symbol-deps ---
u0:10 -> [u0:4]
u0:11 -> [u0:5, u0:6]
u0:12 -> [u0:5, u0:6]
u0:3 <- [u0:7, u0:8]
u0:4 <- [u0:10, u0:9]
u0:5 <- [u0:11, u0:12]
u0:6 <- [u0:11, u0:12]
u0:7 -> [u0:3]
u0:8 -> [u0:3]
u0:9 -> [u0:4]

--- expect:blocks ---
u0:1 | root  | main
u0:2 | class | Foo 
u0:3 | class | Y   
u0:4 | class | T   
u0:5 | class | U   
u0:6 | func  | f1  
u0:7 | func  | f2  
u0:8 | func  | f3  

--- expect:block-deps ---
u0:2 <- [u0:6]
u0:3 <- [u0:7]
u0:4 <- [u0:8]
u0:5 <- [u0:8]
u0:6 -> [u0:2]
u0:7 -> [u0:3]
u0:8 -> [u0:4, u0:5]


===============================================================================
functions-with-custom-types-for-self
===============================================================================


--- file: src/main.rs ---
trait Callback {
    fn call(self: Box<Self>);
}

--- expect:symbols ---
u0:1 | Module   | main     | main                       | [global]
u0:2 | File     | main     | main::main                 |         
u0:3 | Trait    | Callback | main::main::Callback       |         
u0:4 | Function | call     | main::main::Callback::call |         


===============================================================================
constant-items
===============================================================================


--- file: src/main.rs ---
const N: i32 = 5;

trait Foo {
    const X: u8;
}

fn func() {
    println!("{}", N);
}

--- expect:symbols ---
u0:1 | Module   | main | main               | [global]
u0:2 | File     | main | main::main         |         
u0:3 | Const    | N    | main::main::N      |         
u0:4 | Trait    | Foo  | main::main::Foo    |         
u0:5 | Const    | X    | main::main::Foo::X |         
u0:6 | Function | func | main::main::func   |         

--- expect:symbol-deps ---


===============================================================================
static-items
===============================================================================


--- file: src/main.rs ---
static N: i32 = 5;
static mut __progname: *mut ::c_char;

fn func() {
    println!("{}", N);
}

--- expect:symbols ---
u0:1 | Module   | main       | main                   | [global]
u0:2 | File     | main       | main::main             |         
u0:3 | Static   | N          | main::main::N          |         
u0:4 | Static   | __progname | main::main::__progname |         
u0:5 | Function | func       | main::main::func       |         

--- expect:symbol-deps ---


===============================================================================
static-ref-items-using-lazy-static
===============================================================================


--- file: src/main.rs ---
static ref ONE: usize = 0;

fn func() {
    println!("{}", ONE);
}

--- expect:symbols ---
u0:1 | Module   | main | main             | [global]
u0:2 | File     | main | main::main       |         
u0:3 | Static   | ONE  | main::main::ONE  |         
u0:4 | Function | func | main::main::func |         

--- expect:symbol-deps ---


===============================================================================
type-aliases
===============================================================================


--- file: src/main.rs ---
struct Tree<T>;

type Inch = u64;
type Name<T> = Tree<T>;
type LazyResolve = impl (FnOnce() -> Capture) + Send + Sync + UnwindSafe;

--- expect:symbols ---
u0:1 | Module | main        | main                    | [global]
u0:2 | File   | main        | main::main              |         
u0:3 | Struct | Tree        | main::main::Tree        |         
u0:4 | Type   | T           | main::main::Tree::T     |         
u0:5 | Type   | Inch        | main::main::Inch        |         
u0:6 | Type   | Name        | main::main::Name        |         
u0:7 | Type   | T           | main::main::T           |         
u0:8 | Type   | LazyResolve | main::main::LazyResolve |         

--- expect:symbol-deps ---
u0:3 <- [u0:6]
u0:6 -> [u0:3, u0:7]
u0:7 <- [u0:6]


===============================================================================
type-alias-where-clauses
===============================================================================


--- file: src/main.rs ---
type Foo<T> where T: Copy = Box<T>;
type Assoc3 where = () where;

--- expect:symbols ---
u0:1 | Module | main   | main               | [global]
u0:2 | File   | main   | main::main         |         
u0:3 | Type   | Foo    | main::main::Foo    |         
u0:4 | Type   | T      | main::main::T      |         
u0:5 | Type   | Assoc3 | main::main::Assoc3 |         


===============================================================================
empty-statements
===============================================================================


--- file: src/main.rs ---
fn main() {
    ;
}

--- expect:symbols ---
u0:1 | Module   | main | main             | [global]
u0:2 | File     | main | main::main       |         
u0:3 | Function | main | main::main::main |         


===============================================================================
attributes
===============================================================================


--- file: src/main.rs ---
#[test]
fn test_foo() {}

#[derive(Debug)]
struct Baz;

#[derive(Debug, Eq,)]
struct Foo;

#[cfg(target_os = "macos")]
mod macos_only {}

#![allow(clippy::useless_transmute)]

#[clippy::cyclomatic_complexity = "100"]

--- expect:symbols ---
u0:1 | Module    | main       | main                   | [global]
u0:2 | File      | main       | main::main             |         
u0:3 | Function  | test_foo   | main::main::test_foo   |         
u0:4 | Struct    | Baz        | main::main::Baz        |         
u0:5 | Struct    | Foo        | main::main::Foo        |         
u0:6 | Namespace | macos_only | main::main::macos_only |         


===============================================================================
inner-attributes
===============================================================================


--- file: src/main.rs ---
mod macos_only {
  #![cfg(target_os = "macos")]
}

match ty {
    #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]
    syn::Type::Array(ty) => self.visit_type(&ty.elem),
}

--- expect:symbols ---
u0:1 | Module    | main       | main                   | [global]
u0:2 | File      | main       | main::main             |         
u0:3 | Namespace | macos_only | main::main::macos_only |         


===============================================================================
key-value-attribute-expressions
===============================================================================


--- file: src/main.rs ---
#[doc = include_str!("foo-doc.md")]
fn foo() {}

#[namespace = foo::bar]
fn baz() {}

--- expect:symbols ---
u0:1 | Module   | main | main            | [global]
u0:2 | File     | main | main::main      |         
u0:3 | Function | foo  | main::main::foo |         
u0:4 | Function | baz  | main::main::baz |         


===============================================================================
attribute-macros
===============================================================================


--- file: src/main.rs ---
foo(#[attr(=> arbitrary tokens <=)] x, y);

foo(#[bar(some tokens are special in other contexts: $/';()*()+.)] x);

--- expect:symbols ---
u0:1 | Module | main | main       | [global]
u0:2 | File   | main | main::main |         


===============================================================================
derive-macro-helper-attributes
===============================================================================


--- file: src/main.rs ---
// Example from https://github.com/dtolnay/thiserror/blob/21c26903e29cb92ba1a7ff11e82ae2001646b60d/README.md

use thiserror::Error;

pub struct Limits;

#[derive(Error, Debug)]
pub enum Error {
    #[error("first letter must be lowercase but was {:?}", first_char(.0))]
    WrongCase(String),
    #[error("invalid index {idx}, expected at least {} and at most {}", .limits.lo, .limits.hi)]
    OutOfBounds { idx: usize, limits: Limits },
}

--- expect:symbols ---
u0:1 | Module      | main                                       | main                                                          | [global]
u0:2 | File        | main                                       | main::main                                                    |         
u0:3 | Struct      | Limits                                     | main::main::Limits                                            |         
u0:4 | Enum        | Error                                      | main::main::Error                                             |         
u0:5 | EnumVariant | WrongCase(String)                          | main::main::Error::WrongCase(String)                          |         
u0:6 | EnumVariant | OutOfBounds { idx: usize, limits: Limits } | main::main::Error::OutOfBounds { idx: usize, limits: Limits } |         
u0:7 | Field       | idx                                        | main::main::Error::idx                                        |         
u0:8 | Field       | limits                                     | main::main::Error::limits                                     |         

--- expect:symbol-deps ---
u0:3 <- [u0:4, u0:6, u0:8]
u0:4 -> [u0:3, u0:7, u0:8]
u0:6 -> [u0:3, u0:7, u0:8]
u0:7 <- [u0:4, u0:6]
u0:8 -> [u0:3]
u0:8 <- [u0:4, u0:6]


===============================================================================
attributes-and-expressions
===============================================================================


--- file: src/main.rs ---
fn foo() {
   bar(x,
       #[cfg(foo = "bar")]
       y);
   let z = [#[hello] 2, 7, 8];
   let t = (#[hello] 2, 7, 8);
}

fn bar(x: i32, y: i32) {}

--- expect:symbols ---
u0:1 | Module   | main | main               | [global]
u0:2 | File     | main | main::main         |         
u0:3 | Function | foo  | main::main::foo    |         
u0:4 | Variable | z    | main::main::foo::z |         
u0:5 | Variable | t    | main::main::foo::t |         
u0:6 | Function | bar  | main::main::bar    |         
u0:7 | Variable | x    | main::main::bar::x |         
u0:8 | Variable | y    | main::main::bar::y |         

--- expect:symbol-deps ---
u0:3 -> [u0:6]
u0:6 <- [u0:3]


===============================================================================
inherent-impls
===============================================================================


--- file: src/main.rs ---
struct Person;
struct Machine<const STATE: State>;

impl Person {
  const leg_count : u32 = 2;

  fn walk(self) {}
  fn walk_mut(mut self) {}
  fn talk(& self) {}
  fn talk_mut(&'a mut self) {}
}

impl Machine<{State::Init}> {}

--- expect:symbols ---
u0:1 | Module   | main      | main                          | [global]
u0:2 | File     | main      | main::main                    |         
u0:3 | Impl     | Person    | main::main::Person            |         
u0:4 | Impl     | Machine   | main::main::Machine           |         
u0:5 | Const    | leg_count | main::main::Person::leg_count |         
u0:6 | Function | walk      | main::main::Person::walk      |         
u0:7 | Function | walk_mut  | main::main::Person::walk_mut  |         
u0:8 | Function | talk      | main::main::Person::talk      |         
u0:9 | Function | talk_mut  | main::main::Person::talk_mut  |         

--- expect:symbol-deps ---


===============================================================================
inherent-impls-across-multiple-files
===============================================================================


--- file: src/main.rs ---
pub struct Person;

impl Person {
  fn walk(self) {}
}

--- file: src/foo.rs ---
impl Person {
  fn talk(& self) {}
}

--- expect:symbols ---
u0:1 | Module   | main   | main                     | [global]
u0:2 | File     | main   | main::main               |         
u0:3 | Impl     | Person | main::main::Person       |         
u0:4 | Function | walk   | main::main::Person::walk |         
u1:5 | Module   | foo    | foo                      | [global]
u1:6 | File     | foo    | foo::foo                 |         
u1:7 | Impl     | Person | foo::foo::Person         |         
u1:8 | Function | talk   | foo::foo::Person::talk   |         

--- expect:symbol-deps ---


===============================================================================
inherent-impls-no-defines
===============================================================================


--- file: src/main.rs ---
impl Person {
  fn walk(self) {}
}

--- expect:symbols ---
u0:1 | Module   | main   | main                     | [global]
u0:2 | File     | main   | main::main               |         
u0:3 | Impl     | Person | main::main::Person       |         
u0:4 | Function | walk   | main::main::Person::walk |         


===============================================================================
trait-impls
===============================================================================


--- file: src/main.rs ---
impl<'a> iter::Iterator for Self::Iter<'a> {
}

impl ConvertTo<i64> for i32 {
    fn convert(&self) -> i64 { *self as i64 }
}

--- expect:symbols ---
u0:1 | Module   | main    | main                     | [global]
u0:2 | File     | main    | main::main               |         
u0:3 | Impl     | Self    | main::main::Self         |         
u0:4 | Impl     | i32     | main::main::i32          |         
u0:5 | Function | convert | main::main::i32::convert |         


===============================================================================
unsafe-impls
===============================================================================


--- file: src/main.rs ---
unsafe impl Foo {
}

--- expect:symbols ---
u0:1 | Module | main | main            | [global]
u0:2 | File   | main | main::main      |         
u0:3 | Impl   | Foo  | main::main::Foo |         


===============================================================================
disable-automatically-derived-trait-impls
===============================================================================


--- file: src/main.rs ---
impl !Send for Foo {}

--- expect:symbols ---
u0:1 | Module | main | main            | [global]
u0:2 | File   | main | main::main      |         
u0:3 | Impl   | Foo  | main::main::Foo |         


===============================================================================
impl-dyn-with-parentheses
===============================================================================


--- file: src/main.rs ---
pub unsafe trait Trait {}

unsafe impl Trait for dyn (::std::any::Any) + Send { }

--- expect:symbols ---
u0:1 | Module | main       | main                   | [global]
u0:2 | File   | main       | main::main             |         
u0:3 | Trait  | Trait      | main::main::Trait      |         
u0:4 | Impl   | ::std::any | main::main::::std::any |         


===============================================================================
trait-impl-signature
===============================================================================


--- file: src/main.rs ---
impl<K: Debug + Ord> Debug for OccupiedError<K>;
impl<K: Debug + Ord> Display for OccupiedError<K>;

--- expect:symbols ---
u0:1 | Module | main          | main                         | [global]
u0:2 | File   | main          | main::main                   |         
u0:3 | Impl   | OccupiedError | main::main::OccupiedError    |         
u0:4 | Type   | K             | main::main::OccupiedError::K |         
u0:5 | Type   | K             | main::main::OccupiedError::K |         


===============================================================================
impls-with-default-functions
===============================================================================


--- file: src/main.rs ---
impl Foo {
  const default fn bar() -> i32 {
    // Make 'default' still works as an identifier
    default.bar();
  }
}

--- expect:symbols ---
u0:1 | Module   | main | main                 | [global]
u0:2 | File     | main | main::main           |         
u0:3 | Impl     | Foo  | main::main::Foo      |         
u0:4 | Function | bar  | main::main::Foo::bar |         


===============================================================================
trait-declarations
===============================================================================


--- file: src/main.rs ---
pub trait Item: Clone + Eq + fmt::Debug {
    fn summarize(&self) -> Self::Summary;
}

unsafe trait Foo { }

--- expect:symbols ---
u0:1 | Module   | main      | main                        | [global]
u0:2 | File     | main      | main::main                  |         
u0:3 | Trait    | Item      | main::main::Item            |         
u0:4 | Function | summarize | main::main::Item::summarize |         
u0:5 | Trait    | Foo       | main::main::Foo             |         


===============================================================================
trait-declarations-with-optional-type-parameters
===============================================================================


--- file: src/main.rs ---
struct Foo;

trait Add<RHS=Foo> {
    type Output;
    fn add(self, rhs: RHS) -> Self::Output;
}

--- expect:symbols ---
u0:1 | Module   | main   | main                    | [global]
u0:2 | File     | main   | main::main              |         
u0:3 | Struct   | Foo    | main::main::Foo         |         
u0:4 | Trait    | Add    | main::main::Add         |         
u0:5 | Type     | RHS    | main::main::Add::RHS    |         
u0:6 | Type     | Output | main::main::Add::Output |         
u0:7 | Function | add    | main::main::Add::add    |         
u0:8 | Variable | rhs    | main::main::Add::rhs    |         

--- expect:symbol-deps ---
u0:3 <- [u0:4, u0:5]
u0:4 -> [u0:3, u0:5, u0:6]
u0:5 -> [u0:3]
u0:5 <- [u0:4, u0:8]
u0:6 <- [u0:4, u0:7]
u0:7 -> [u0:6]
u0:8 -> [u0:5]


===============================================================================
unsized-types-in-trait-bounds
===============================================================================


--- file: src/main.rs ---
trait Foo<T: ?Sized> {
}

fn univariant(this: &impl ?Sized, that: &(impl LayoutCalculator + ?Sized)) {}

--- expect:symbols ---
u0:1 | Module   | main       | main                         | [global]
u0:2 | File     | main       | main::main                   |         
u0:3 | Trait    | Foo        | main::main::Foo              |         
u0:4 | Type     | T          | main::main::Foo::T           |         
u0:5 | Function | univariant | main::main::univariant       |         
u0:6 | Variable | this       | main::main::univariant::this |         
u0:7 | Variable | that       | main::main::univariant::that |         


===============================================================================
trait-bounds-in-type-arguments-in-trait
===============================================================================


--- file: src/main.rs ---
impl<T: AstDeref<Target: HasNodeId>> HasNodeId for T {}

--- expect:symbols ---
u0:1 | Module | main | main             | [global]
u0:2 | File   | main | main::main       |         
u0:3 | Impl   | T    | main::main::T    |         
u0:4 | Type   | T    | main::main::T::T |         


===============================================================================
macro-invocations-inside-trait-declarations
===============================================================================


--- file: src/main.rs ---
pub trait A: B + C + D {
    private_decl!{}
    fn f(&self);
}

--- expect:symbols ---
u0:1 | Module   | main | main             | [global]
u0:2 | File     | main | main::main       |         
u0:3 | Trait    | A    | main::main::A    |         
u0:4 | Function | f    | main::main::A::f |         


===============================================================================
associated-types
===============================================================================


--- file: src/main.rs ---
pub trait Graph {
    type N: fmt::Display;
    type E;
}

--- expect:symbols ---
u0:1 | Module | main  | main                 | [global]
u0:2 | File   | main  | main::main           |         
u0:3 | Trait  | Graph | main::main::Graph    |         
u0:4 | Type   | N     | main::main::Graph::N |         
u0:5 | Type   | E     | main::main::Graph::E |         


===============================================================================
associated-type-definitions
===============================================================================


--- file: src/main.rs ---
impl Trait for T {
    type Associated = T where 'static: 'static;
}

--- expect:symbols ---
u0:1 | Module | main       | main                      | [global]
u0:2 | File   | main       | main::main                |         
u0:3 | Impl   | T          | main::main::T             |         
u0:4 | Type   | Associated | main::main::T::Associated |         

--- expect:symbol-deps ---
u0:3 <- [u0:4]
u0:4 -> [u0:3]


===============================================================================
generic-associated-types
===============================================================================


--- file: src/main.rs ---
pub trait Database {
    type F<'a, D>: Future<Output = D> + 'a;
}

impl Database for Foo {
    type F<'a, D> = DatabaseFuture<'a, D>;
}

fn use_database1<D: Database<F<'a, TD> = F>>() {}

fn use_database2<D>()
where
    D: Database<F<'a, TD> = F>,
{}

--- expect:symbols ---
u0:1  | Module   | main          | main                         | [global]
u0:2  | File     | main          | main::main                   |         
u0:3  | Trait    | Database      | main::main::Database         |         
u0:4  | Type     | F             | main::main::Database::F      |         
u0:5  | Type     | D             | main::main::Database::D      |         
u0:6  | Impl     | Foo           | main::main::Foo              |         
u0:7  | Type     | F             | main::main::Foo::F           |         
u0:8  | Type     | D             | main::main::Foo::D           |         
u0:9  | Function | use_database1 | main::main::use_database1    |         
u0:10 | Type     | D             | main::main::use_database1::D |         
u0:11 | Function | use_database2 | main::main::use_database2    |         
u0:12 | Type     | D             | main::main::use_database2::D |         


===============================================================================
higher-ranked-types-basic
===============================================================================


--- file: src/main.rs ---
struct AddAssign<T>;

trait T: for<'a> AddAssign<&'a usize> {
}

type FnObject<'b> = dyn for<'a> FnLike<&'a isize, &'a isize> + 'b;

--- expect:symbols ---
u0:1 | Module | main      | main                     | [global]
u0:2 | File   | main      | main::main               |         
u0:3 | Struct | AddAssign | main::main::AddAssign    |         
u0:4 | Type   | T         | main::main::AddAssign::T |         
u0:5 | Trait  | T         | main::main::T            |         
u0:6 | Type   | FnObject  | main::main::FnObject     |         

--- expect:symbol-deps ---


===============================================================================
higher-ranked-types-with-trait-bounds
===============================================================================


--- file: src/main.rs ---
trait Foo {};
trait Bar {};
trait Baz<T> {};

struct AddAssign<T: Foo, U: Baz<u32>>;

trait T: for<'a> AddAssign<&'a usize> {
}

type FnObject<'b> = dyn for<'a> FnLike<&'a isize, &'a isize> + 'b;

--- expect:symbols ---
u0:1  | Module | main      | main                     | [global]
u0:2  | File   | main      | main::main               |         
u0:3  | Trait  | Foo       | main::main::Foo          |         
u0:4  | Trait  | Bar       | main::main::Bar          |         
u0:5  | Trait  | Baz       | main::main::Baz          |         
u0:6  | Type   | T         | main::main::Baz::T       |         
u0:7  | Struct | AddAssign | main::main::AddAssign    |         
u0:8  | Type   | T         | main::main::AddAssign::T |         
u0:9  | Type   | U         | main::main::AddAssign::U |         
u0:10 | Trait  | T         | main::main::T            |         
u0:11 | Type   | FnObject  | main::main::FnObject     |         

--- expect:symbol-deps ---


===============================================================================
visibility-modifiers
===============================================================================


--- file: src/main.rs ---
pub fn a() {}
pub(super) fn b() {}
pub(self) fn c() {}
pub(crate) fn c() {}
pub(in crate::d) fn e() {}

--- expect:symbols ---
u0:1 | Module   | main | main          | [global]
u0:2 | File     | main | main::main    |         
u0:3 | Function | a    | main::main::a |         
u0:4 | Function | b    | main::main::b |         
u0:5 | Function | c    | main::main::c |         
u0:6 | Function | e    | main::main::e |         


===============================================================================
function-parameter-names-that-match-built-in-type-names
===============================================================================


--- file: src/main.rs ---
fn foo(str: *const c_char) {}
fn bar(bool: bool) {}

--- expect:symbols ---
u0:1 | Module   | main | main                  | [global]
u0:2 | File     | main | main::main            |         
u0:3 | Function | foo  | main::main::foo       |         
u0:4 | Variable | str  | main::main::foo::str  |         
u0:5 | Function | bar  | main::main::bar       |         
u0:6 | Variable | bool | main::main::bar::bool |         


===============================================================================
where-clauses
===============================================================================


--- file: src/main.rs ---
fn walk<F>(&self, it: &mut F) -> bool
    where F: FnMut(&Pat) -> bool
{
  return false
}

impl<'a, T: 'a + Item> Iterator for Iter<'a, T> where Self: 'a {
}

impl<T> A for B<T>
    where C<T>: D,
          T: 'c,
          'c: 'b,
{
}

impl<'a, E> Read
where &'a E: Read,
{
}

impl<T> A for B<T> where (T, T, T): C, {}

impl<T> A for B<T>
    where for<'a> D<T>: E<'a>,
{
}

pub trait A<B> where B: C,
{
}

struct Foo;

fn foo<A>() where A: Foo + As<f64>, f64: As<A> {}

impl<A> Default for B<A> where *mut A: C + D {}

--- expect:symbols ---
u0:1  | Module   | main | main                 | [global]
u0:2  | File     | main | main::main           |         
u0:3  | Function | walk | main::main::walk     |         
u0:4  | Type     | F    | main::main::walk::F  |         
u0:5  | Variable | it   | main::main::walk::it |         
u0:6  | Impl     | Iter | main::main::Iter     |         
u0:7  | Type     | T    | main::main::Iter::T  |         
u0:8  | Impl     | B    | main::main::B        |         
u0:9  | Type     | T    | main::main::B::T     |         
u0:10 | Impl     | Read | main::main::Read     |         
u0:11 | Type     | E    | main::main::Read::E  |         
u0:12 | Type     | T    | main::main::B::T     |         
u0:13 | Type     | T    | main::main::B::T     |         
u0:14 | Trait    | A    | main::main::A        |         
u0:15 | Type     | B    | main::main::A::B     |         
u0:16 | Struct   | Foo  | main::main::Foo      |         
u0:17 | Function | foo  | main::main::foo      |         
u0:18 | Type     | A    | main::main::foo::A   |         
u0:19 | Type     | A    | main::main::B::A     |         

--- expect:symbol-deps ---
u0:14 <- [u0:8]
u0:3 -> [u0:4]
u0:4 <- [u0:3, u0:5]
u0:5 -> [u0:4]
u0:8 -> [u0:14]


===============================================================================
external-modules
===============================================================================


--- file: src/main.rs ---
extern {
  pub fn napi_module_register(mod_: *mut napi_module);
}

extern "C" {}

unsafe extern "C" {}

--- expect:symbols ---
u0:1 | Module   | main                 | main                             | [global]
u0:2 | File     | main                 | main::main                       |         
u0:3 | Function | napi_module_register | main::main::napi_module_register |         
u0:4 | Variable | mod_                 | main::main::mod_                 |         


===============================================================================
crate-visibility
===============================================================================


--- file: src/main.rs ---
crate mod foo;
crate struct Foo(crate crate::Bar);
crate fn foo() { }
crate const X: u32 = 0;

--- expect:symbols ---
u0:1 | Module   | main | main            | [global]
u0:2 | File     | main | main::main      |         
u0:3 | Struct   | Foo  | main::main::Foo |         
u0:4 | Function | foo  | main::main::foo |         
u0:5 | Const    | X    | main::main::X   |         


===============================================================================
reserved-keywords-in-path
===============================================================================


--- file: src/main.rs ---
struct B;
struct C;

struct A {
  a: default::B,
  b: union::C,
}

--- expect:symbols ---
u0:1 | Module | main | main             | [global]
u0:2 | File   | main | main::main       |         
u0:3 | Struct | B    | main::main::B    |         
u0:4 | Struct | C    | main::main::C    |         
u0:5 | Struct | A    | main::main::A    |         
u0:6 | Field  | a    | main::main::A::a |         
u0:7 | Field  | b    | main::main::A::b |         

--- expect:symbol-deps ---
u0:3 <- [u0:5, u0:6]
u0:4 <- [u0:5, u0:7]
u0:5 -> [u0:3, u0:4]
u0:6 -> [u0:3]
u0:7 -> [u0:4]


===============================================================================
array-constraint-in-where-clause
===============================================================================


--- file: src/main.rs ---
struct D;

fn foo<D>(val: D)
where
    [u8; 32]: From<D>,

{}

--- expect:symbols ---
u0:1 | Module   | main | main                 | [global]
u0:2 | File     | main | main::main           |         
u0:3 | Struct   | D    | main::main::D        |         
u0:4 | Function | foo  | main::main::foo      |         
u0:5 | Type     | D    | main::main::foo::D   |         
u0:6 | Variable | val  | main::main::foo::val |         

--- expect:symbol-deps ---
u0:4 -> [u0:5]
u0:5 <- [u0:4, u0:6]
u0:6 -> [u0:5]


===============================================================================
const-generics-with-default
===============================================================================


--- file: src/main.rs ---
pub struct Loaf<T: Sized, const N: usize = 1>([T; N]);

--- expect:symbols ---
u0:1 | Module | main | main                | [global]
u0:2 | File   | main | main::main          |         
u0:3 | Struct | Loaf | main::main::Loaf    |         
u0:4 | Type   | T    | main::main::Loaf::T |         
