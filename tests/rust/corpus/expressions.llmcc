===============================================================================
basic-identifiers
===============================================================================


--- file: src/main.rs ---
fn main() {
  abc;
}

--- expect:symbols ---
u0:1 | Function | main | main |




===============================================================================
raw-identifiers
===============================================================================


--- file: src/main.rs ---
fn main() {
  (r#abc as r#Def).r#ghi;
}

--- expect:symbols ---
u0:1 | Function | main | main |




===============================================================================
unary-operator-expressions
===============================================================================


--- file: src/main.rs ---
-num;
!bits;
*boxed_thing;

--- expect:symbols ---
none



===============================================================================
reference-expressions
===============================================================================


--- file: src/main.rs ---
&a;
&mut self.name;
&raw const b;
&raw mut self.age;

--- expect:symbols ---
none



===============================================================================
try-expressions
===============================================================================


--- file: src/main.rs ---
a.unwrap()?;
&a?;

--- expect:symbols ---
none



===============================================================================
binary-operator-expressions
===============================================================================


--- file: src/main.rs ---
a * b;
a / b;
a % b;
a + b;
a - b;
a >> b;
a << b;
a == b;
a && b;
a || b;

--- expect:symbols ---
none




===============================================================================
grouped-expressions
===============================================================================


--- file: src/main.rs ---
(0);
(2 * (3 + 4));

--- expect:symbols ---
none



===============================================================================
range-expressions
===============================================================================


--- file: src/main.rs ---
1..2;
3..;
..4;
..;
1..b;
a..b;
1..(1);
(1)..1;
(1)..(1);
1..{1};
for i in 1.. {
}

--- expect:symbols ---
none



===============================================================================
assignment-expressions
===============================================================================


--- file: src/main.rs ---
x = y;

--- expect:symbols ---
none




===============================================================================
compound-assignment-expressions
===============================================================================


--- file: src/main.rs ---
x += 1;
x += y;

--- expect:symbols ---
none



===============================================================================
type-cast-expressions
===============================================================================


--- file: src/main.rs ---
struct Foo;

fn func() {
  1000 as u8;
  let character = integer as Foo;
  let size: f64 = 1.0 + -len(values) as f64 + 1.0;
}

--- expect:symbols ---
u0:1 | Struct   | Foo  | Foo  |
u0:2 | Function | func | func |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]



===============================================================================
call-expressions
===============================================================================


--- file: src/main.rs ---
struct Foo;
struct Bar;

fn func() {
  let f = Foo::new();
  let b: Bar = Bar::new(42);
  foo();
  add(f, b);
}

--- expect:symbols ---
u0:1 | Struct   | Foo  | Foo  |
u0:2 | Struct   | Bar  | Bar  |
u0:3 | Function | func | func |


--- expect:symbol-deps ---
u0:1 <- [u0:3]
u0:2 <- [u0:3]
u0:3 -> [u0:1, u0:2]




===============================================================================
call-expressions-chained
===============================================================================


--- file: app/src/main.rs ---
struct Foo;
struct Bar;

fn func() {
  let f = Foo::new();
  let b: Bar = Bar::new(42);
  foo();
  add(f).compute(b).finalize();
}

--- expect:symbols ---
u0:1 | Struct   | Foo  | Foo  |
u0:2 | Struct   | Bar  | Bar  |
u0:3 | Function | func | func |


--- expect:symbol-deps ---
u0:1 <- [u0:3]
u0:2 <- [u0:3]
u0:3 -> [u0:1, u0:2]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Foo
u0:3 | class | Bar
u0:4 | func  | func
u0:5 | call  | block#5
u0:6 | call  | block#6
u0:7 | call  | block#7
u0:8 | call  | block#8

--- expect:block-deps ---
u0:2 <- [u0:4]
u0:3 <- [u0:4]
u0:4 -> [u0:2, u0:3]

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Foo", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="Bar", full_path="$TMP/app/src/main.rs:2"];
    n3 [label="func", full_path="$TMP/app/src/main.rs:4"];
  }
  n3 -> n1;
  n3 -> n2;
}



===============================================================================
call-expressions-nested
===============================================================================


--- file: app/src/main.rs ---
struct Foo;
struct Bar;

fn func() {
  let f = Foo::new();
  let b: Bar = Bar::new(42);
  foo();
  add(f, compute(b));
}

--- expect:symbols ---
u0:1 | Struct   | Foo  | Foo  |
u0:2 | Struct   | Bar  | Bar  |
u0:3 | Function | func | func |


--- expect:symbol-deps ---
u0:1 <- [u0:3]
u0:2 <- [u0:3]
u0:3 -> [u0:1, u0:2]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Foo
u0:3 | class | Bar
u0:4 | func  | func
u0:5 | call  | block#5
u0:6 | call  | block#6
u0:7 | call  | block#7
u0:8 | call  | block#8

--- expect:block-deps ---
u0:2 <- [u0:4]
u0:3 <- [u0:4]
u0:4 -> [u0:2, u0:3]

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Foo", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="Bar", full_path="$TMP/app/src/main.rs:2"];
    n3 [label="func", full_path="$TMP/app/src/main.rs:4"];
  }
  n3 -> n1;
  n3 -> n2;
}



===============================================================================
array-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Foo;

fn foo() {
  let a = Foo::new();
  [];
  let b = [1, a, 3];
  ["a", "b", "c"];
  [0; 128];
  [
      #[cfg(foo)]
      "foo",
      #[cfg(bar)]
      "bar",
  ];
}

--- expect:symbols ---
u0:1 | Struct   | Foo | Foo |
u0:2 | Function | foo | foo |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Foo
u0:3 | func  | foo
u0:4 | call  | block#4

--- expect:block-deps ---
u0:2 <- [u0:3]
u0:3 -> [u0:2]

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Foo", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="foo", full_path="$TMP/app/src/main.rs:3"];
  }
  n2 -> n1;
}



===============================================================================
tuple-expressions
===============================================================================


--- file: app/src/main.rs ---
struct TupleThing;

fn make_tuples() {
  let empty = ();
  let single = (TupleThing,);
  let triple = (TupleThing, 2, 3);
  let nested = ((1, 2), (3, 4));
  let destructured = match triple {
    (a, b, c) => (a, b, c),
  };
  let _all = (empty, single, nested, destructured);
}

--- expect:symbols ---
u0:1 | Struct   | TupleThing  | TupleThing  |
u0:2 | Function | make_tuples | make_tuples |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | TupleThing
u0:3 | func  | make_tuples

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="TupleThing", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="make_tuples", full_path="$TMP/app/src/main.rs:3"];
  }
  n2 -> n1;
}



===============================================================================
struct-expressions
===============================================================================


--- file: app/src/main.rs ---
struct SomeStruct {
    field1: i32,
    field2: String,
    field3: f64,
}

fn func() {
  NothingInMe {};
  Point {x: 10.0, y: 20.0};
  let a = SomeStruct { field1, field2: expression, field3, };
  let u = game::User {name: "Joe", age: 35, score: 100_000};
  let i = Instant { 0: Duration::from_millis(0) };
}

--- expect:symbols ---
u0:1 | Struct   | SomeStruct | SomeStruct |
u0:2 | Function | func       | func       |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | SomeStruct
u0:3 | func  | func
u0:4 | call  | block#4

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="SomeStruct", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="func", full_path="$TMP/app/src/main.rs:7"];
  }
  n2 -> n1;
}





===============================================================================
struct-expressions-with-update-initializers
===============================================================================


--- file: app/src/main.rs ---
struct User {
    id: u32,
    score: u32,
}

fn build_user(score: u32) -> User {
  let base = User { id: 1, score: 10 };
  User {
    score,
    ..base
  }
}

--- expect:symbols ---
u0:1 | Struct   | User       | User       |
u0:2 | Function | build_user | build_user |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | User
u0:3 | func  | build_user

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="User", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="build_user", full_path="$TMP/app/src/main.rs:6"];
  }
  n2 -> n1;
}


===============================================================================
if-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Config {
  n: i32,
  x: i32,
}

fn main() {
  let cfg = Config { n: 1, x: 5 };
  if cfg.n == 1 {
  } else if cfg.n == 2 {
  } else {
  }

  let y = if cfg.x == 5 { 10 } else { 15 };

  if cfg.x > 0 && cfg.n > 0 {}

  if cfg.x > 0 || cfg.n > 0 {}
}

--- expect:symbols ---
u0:1 | Struct   | Config | Config |
u0:2 | Function | main   | main   |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Config
u0:3 | func  | main

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Config", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="main", full_path="$TMP/app/src/main.rs:6"];
  }
  n2 -> n1;
}



===============================================================================
basic-if-let-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Guard {
  val: Option<i32>,
}

fn check() {
  let guard = Guard { val: Some(42) };
  if let Some(a) = guard.val
    && a > 0
  {
  }
}

--- expect:symbols ---
u0:1 | Struct   | Guard | Guard |
u0:2 | Function | check | check |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Guard
u0:3 | func  | check
u0:4 | call  | block#4

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Guard", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="check", full_path="$TMP/app/src/main.rs:5"];
  }
  n2 -> n1;
}



===============================================================================
if-let-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Dish;
fn parse() {
  let dish_opt = Some(Dish);
  if let Some(dish) = dish_opt {
  }

  if let Some("chained") = a && b && let (C, D) = e {
  }

  if foo && let bar = || baz && quux {}
  if a && let b = || c || d && e {}
}

--- expect:symbols ---
u0:1 | Struct   | Dish  | Dish  |
u0:2 | Function | parse | parse |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Dish
u0:3 | func  | parse
u0:4 | call  | block#4

--- expect:block-deps ---
u0:2 <- [u0:3]
u0:3 -> [u0:2]

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Dish", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="parse", full_path="$TMP/app/src/main.rs:2"];
  }
  n2 -> n1;
}




===============================================================================
while-let-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Queue {
  items: Option<Vec<i32>>,
}

fn process() {
  let queue = Queue { items: Some(vec![]) };
  while let Some(items) = queue.items {
    let _ = items;
  }
}

--- expect:symbols ---
u0:1 | Struct   | Queue   | Queue   |
u0:2 | Function | process | process |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Queue
u0:3 | func  | process
u0:4 | call  | block#4

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Queue", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="process", full_path="$TMP/app/src/main.rs:5"];
  }
  n2 -> n1;
}



===============================================================================
match-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Value;

fn process_value() {
  let val = Value;
  match val {
    _ => {},
  }
}

--- expect:symbols ---
u0:1 | Struct   | Value   | Value   |
u0:2 | Function | process_value | process_value |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Value
u0:3 | func  | process_value

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Value", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="process_value", full_path="$TMP/app/src/main.rs:3"];
  }
  n2 -> n1;
}



===============================================================================
while-expressions
===============================================================================


--- file: app/src/main.rs ---
struct State {
  done: bool,
}

fn loop_until() {
  let state = State { done: false };
  while !state.done {
    let _ = state.done;
  }
}

--- expect:symbols ---
u0:1 | Struct   | State      | State      |
u0:2 | Function | loop_until | loop_until |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | State
u0:3 | func  | loop_until

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="State", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="loop_until", full_path="$TMP/app/src/main.rs:5"];
  }
  n2 -> n1;
}



===============================================================================
loop-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Counter {
  limit: i32,
}

fn count() {
  let counter = Counter { limit: 10 };
  'outer: loop {
    'inner: loop {
      break 'outer;
    }
  }
}

--- expect:symbols ---
u0:1 | Struct   | Counter | Counter |
u0:2 | Function | count   | count   |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Counter
u0:3 | func  | count

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Counter", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="count", full_path="$TMP/app/src/main.rs:5"];
  }
  n2 -> n1;
}



===============================================================================
for-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Container;

fn iterate() {
  let container = Container;
  for i in 0..10 {
    let _ = i;
  }
}

--- expect:symbols ---
u0:1 | Struct   | Container | Container |
u0:2 | Function | iterate   | iterate   |

--- expect:symbol-deps ---
u0:1 <- [u0:2]
u0:2 -> [u0:1]

--- expect:blocks ---
u0:1 | root  | block#1
u0:2 | class | Container
u0:3 | func  | iterate

--- expect:graph ---
digraph project {
  subgraph cluster_0 {
    label="app";
    style=filled;
    color=lightgrey;
    n1 [label="Container", full_path="$TMP/app/src/main.rs:1"];
    n2 [label="iterate", full_path="$TMP/app/src/main.rs:3"];
  }
  n2 -> n1;
}



===============================================================================
field-expressions
===============================================================================


--- file: src/main.rs ---
struct Foo;
struct Baz {
  x: i32,
}

struct MyStruct {
  myfield: Foo,
}

fn foo() -> Baz {
  Baz
}

fn bar() {
  let x = mystruct.myfield;
  let y = foo().x;
  value.0.1.iter();
  1.max(2);
}

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
method-call-expressions
===============================================================================


--- file: src/main.rs ---
mystruct.foo();

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
index-expressions
===============================================================================


--- file: src/main.rs ---
([1, 2, 3, 4])[0];
arr[10];
arr[n];

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
scoped-functions
===============================================================================


--- file: src/main.rs ---
a::b();
C::<D>::e();
::f();
::g::h();

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
scoped-functions-with-fully-qualified-syntax
===============================================================================


--- file: src/main.rs ---
<Dog as Animal>::eat(d);

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
scoped-functions-with-macros-as-types
===============================================================================


--- file: src/main.rs ---
<Token![]>::foo();

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
scoped-identifier-with-nested-super
===============================================================================


--- file: src/main.rs ---
super::super::foo();

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
generic-functions
===============================================================================


--- file: src/main.rs ---
std::sizeof::<u32>();
foo::<8>();

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
closures
===============================================================================


--- file: src/main.rs ---
a.map(|(b, c)| b.push(c));
d.map(move |mut e| {
    f(e);
    g(e)
});
h(|| -> i { j });

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
closures-with-typed-parameteres
===============================================================================


--- file: src/main.rs ---
a.map(|b: usize| b.push(c));

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
generators
===============================================================================


--- file: src/main.rs ---
move || {
    while i <= n {
        yield i;
        i += 1;
    }
    return;
};

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
unsafe-blocks
===============================================================================


--- file: src/main.rs ---
const a : A = unsafe { foo() };

--- expect:symbols ---
u0:1 | Const | a | a |

--- expect:graph ---
digraph project {
}



===============================================================================
inline-const-or-const-blocks-as-expression
===============================================================================


--- file: src/main.rs ---
const { 1 + 3 };
if *x < 0 { const { &4i32.pow(4) } } else { x }
let three_ranges = [const { (0..=5).into_inner() }; 3];

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}



===============================================================================
raw-reference-expression-conflicts
===============================================================================


--- file: src/main.rs ---
some_call(&raw);
let a = &raw const b;

--- expect:symbols ---
none

--- expect:graph ---
digraph project {
}

