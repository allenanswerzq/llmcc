===============================================================================
basic-identifiers
===============================================================================


--- file: src/main.rs ---
abc;






===============================================================================
raw-identifiers
===============================================================================


--- file: src/main.rs ---
(r#abc as r#Def).r#ghi;






===============================================================================
unary-operator-expressions
===============================================================================


--- file: src/main.rs ---
-num;
!bits;
*boxed_thing;






===============================================================================
reference-expressions
===============================================================================


--- file: src/main.rs ---
&a;
&mut self.name;
&raw const b;
&raw mut self.age;





===============================================================================
try-expressions
===============================================================================


--- file: src/main.rs ---
a.unwrap()?;
&a?;





===============================================================================
binary-operator-expressions
===============================================================================


--- file: src/main.rs ---
a * b;
a / b;
a % b;
a + b;
a - b;
a >> b;
a << b;
a == b;
a && b;
a || b;






===============================================================================
grouped-expressions
===============================================================================


--- file: src/main.rs ---
(0);
(2 * (3 + 4));





===============================================================================
range-expressions
===============================================================================


--- file: src/main.rs ---
1..2;
3..;
..4;
..;
1..b;
a..b;
1..(1);
(1)..1;
(1)..(1);
1..{1};
for i in 1.. {
}





===============================================================================
assignment-expressions
===============================================================================


--- file: src/main.rs ---
x = y;





===============================================================================
compound-assignment-expressions
===============================================================================


--- file: src/main.rs ---
x += 1;
x += y;





===============================================================================
type-cast-expressions
===============================================================================


--- file: src/main.rs ---
struct Foo;
1000 as u8;
let character = integer as Foo;
let size: f64 = 1.0 + -len(values) as f64 + 1.0;





===============================================================================
call-expressions-basic
===============================================================================


--- file: src/main.rs ---
struct Foo;
struct Bar;

fn func() {
  let f = Foo::new();
  let b: Bar = Bar::new(42);
  foo();
  add(f, b);
}

--- expect:symbols ---
u0:1 | Module   | main | main | [global]
u0:2 | File     | main | main |         
u0:3 | Struct   | Foo  | Foo  |         
u0:4 | Struct   | Bar  | Bar  |         
u0:5 | Function | func | func |         
u0:6 | Variable | f    | f    |         
u0:7 | Variable | b    | b    |         

--- expect:symbol-deps ---
u0:4 <- [u0:7]
u0:7 -> [u0:4]




===============================================================================
call-expressions-chained
===============================================================================


--- file: app/src/main.rs ---
struct Foo;
struct Bar;

fn func() {
  let f = Foo::new();
  let b: Bar = Bar::new(42);
  foo();
  add(f).compute(b).finalize();
}

--- expect:symbols ---
u0:1 | Module   | main | main | [global]
u0:2 | File     | main | main |         
u0:3 | Struct   | Foo  | Foo  |         
u0:4 | Struct   | Bar  | Bar  |         
u0:5 | Function | func | func |         
u0:6 | Variable | f    | f    |         
u0:7 | Variable | b    | b    |         

--- expect:symbol-deps ---
u0:4 <- [u0:7]
u0:7 -> [u0:4]

--- expect:blocks ---
u0:20 | root  | main    
u0:21 | class | Foo     
u0:22 | class | Bar     
u0:23 | func  | func    
u0:24 | call  | block#24
u0:25 | call  | block#25
u0:26 | call  | block#26
u0:27 | call  | block#27

--- expect:block-deps ---


--- expect:graph ---
digraph project {
}




===============================================================================
call-expressions-nested
===============================================================================


--- file: app/src/main.rs ---
struct Foo;
struct Bar;

fn func() {
  let f = Foo::new();
  let b: Bar = Bar::new(42);
  foo();
  add(f, compute(b));
}

--- expect:symbols ---
u0:1 | Module   | main | main | [global]
u0:2 | File     | main | main |         
u0:3 | Struct   | Foo  | Foo  |         
u0:4 | Struct   | Bar  | Bar  |         
u0:5 | Function | func | func |         
u0:6 | Variable | f    | f    |         
u0:7 | Variable | b    | b    |         

--- expect:symbol-deps ---
u0:4 <- [u0:7]
u0:7 -> [u0:4]

--- expect:blocks ---
u0:28 | root  | main    
u0:29 | class | Foo     
u0:30 | class | Bar     
u0:31 | func  | func    
u0:32 | call  | block#32
u0:33 | call  | block#33
u0:34 | call  | block#34
u0:35 | call  | block#35

--- expect:block-deps ---


--- expect:graph ---
digraph project {
}




===============================================================================
array-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Foo;

fn foo() {
  let a = Foo::new();
  [];
  let b = [1, a, 3];
  ["a", "b", "c"];
  [0; 128];
  [
      #[cfg(foo)]
      "foo",
      #[cfg(bar)]
      "bar",
  ];
}

--- expect:symbols ---
u0:1 | Module   | main | main | [global]
u0:2 | File     | main | main |         
u0:3 | Struct   | Foo  | Foo  |         
u0:4 | Function | foo  | foo  |         
u0:5 | Variable | a    | a    |         
u0:6 | Variable | b    | b    |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:36 | root  | main    
u0:37 | class | Foo     
u0:38 | func  | foo     
u0:39 | call  | block#39

--- expect:block-deps ---


--- expect:graph ---
digraph project {
}




===============================================================================
tuple-expressions
===============================================================================


--- file: app/src/main.rs ---
struct TupleThing;

fn make_tuples() {
  let empty = ();
  let single = (TupleThing,);
  let triple = (TupleThing, 2, 3);
  let nested = ((1, 2), (3, 4));
  let destructured = match triple {
    (a, b, c) => (a, b, c),
  };
  let _all = (empty, single, nested, destructured);
}

--- expect:symbols ---
u0:1  | Module   | main         | main         | [global]
u0:2  | File     | main         | main         |         
u0:3  | Struct   | TupleThing   | TupleThing   |         
u0:4  | Function | make_tuples  | make_tuples  |         
u0:5  | Variable | empty        | empty        |         
u0:6  | Variable | single       | single       |         
u0:7  | Variable | triple       | triple       |         
u0:8  | Variable | nested       | nested       |         
u0:9  | Variable | destructured | destructured |         
u0:10 | Variable | _all         | _all         |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:40 | root  | main       
u0:41 | class | TupleThing 
u0:42 | func  | make_tuples

--- expect:graph ---
digraph project {
}




===============================================================================
struct-expressions
===============================================================================


--- file: app/src/main.rs ---
struct SomeStruct {
    field1: i32,
    field2: String,
    field3: f64,
}

fn func() {
  NothingInMe {};
  Point {x: 10.0, y: 20.0};
  let a = SomeStruct { field1, field2: expression, field3, };
  let u = game::User {name: "Joe", age: 35, score: 100_000};
  let i = Instant { 0: Duration::from_millis(0) };
}

--- expect:symbols ---
u0:1  | Module   | main       | main       | [global]
u0:2  | File     | main       | main       |         
u0:3  | Struct   | SomeStruct | SomeStruct |         
u0:4  | Field    | field1     | field1     |         
u0:5  | Field    | field2     | field2     |         
u0:6  | Field    | field3     | field3     |         
u0:7  | Function | func       | func       |         
u0:8  | Variable | a          | a          |         
u0:9  | Variable | u          | u          |         
u0:10 | Variable | i          | i          |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:43 | root  | main      
u0:44 | class | SomeStruct
u0:45 | field | block#45  
u0:46 | field | block#46  
u0:47 | field | block#47  
u0:48 | func  | func      
u0:49 | call  | block#49  

--- expect:graph ---
digraph project {
}




===============================================================================
struct-expressions-with-update-initializers
===============================================================================


--- file: app/src/main.rs ---
struct User {
    id: u32,
    score: u32,
}

fn build_user(score: u32) -> User {
  let base = User { id: 1, score: 10 };
  User {
    score,
    ..base
  }
}

--- expect:symbols ---
u0:1 | Module   | main       | main       | [global]
u0:2 | File     | main       | main       |         
u0:3 | Struct   | User       | User       |         
u0:4 | Field    | id         | id         |         
u0:5 | Field    | score      | score      |         
u0:6 | Function | build_user | build_user |         
u0:7 | Variable | score      | score      |         
u0:8 | Variable | base       | base       |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:50 | root  | main      
u0:51 | class | User      
u0:52 | field | block#52  
u0:53 | field | block#53  
u0:54 | func  | build_user

--- expect:graph ---
digraph project {
}




===============================================================================
if-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Config {
  n: i32,
  x: i32,
}

fn main() {
  let cfg = Config { n: 1, x: 5 };
  if cfg.n == 1 {
  } else if cfg.n == 2 {
  } else {
  }

  let y = if cfg.x == 5 { 10 } else { 15 };

  if cfg.x > 0 && cfg.n > 0 {}

  if cfg.x > 0 || cfg.n > 0 {}
}

--- expect:symbols ---
u0:1 | Module   | main   | main   | [global]
u0:2 | File     | main   | main   |         
u0:3 | Struct   | Config | Config |         
u0:4 | Field    | n      | n      |         
u0:5 | Field    | x      | x      |         
u0:6 | Function | main   | main   |         
u0:7 | Variable | cfg    | cfg    |         
u0:8 | Variable | y      | y      |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:55 | root  | main    
u0:56 | class | Config  
u0:57 | field | block#57
u0:58 | field | block#58
u0:59 | func  | main    

--- expect:graph ---
digraph project {
}




===============================================================================
basic-if-let-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Guard {
  val: Option<i32>,
}

fn check() {
  let guard = Guard { val: Some(42) };
  if let Some(a) = guard.val
    && a > 0
  {
  }
}

--- expect:symbols ---
u0:1 | Module   | main  | main  | [global]
u0:2 | File     | main  | main  |         
u0:3 | Struct   | Guard | Guard |         
u0:4 | Field    | val   | val   |         
u0:5 | Function | check | check |         
u0:6 | Variable | guard | guard |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:60 | root  | main    
u0:61 | class | Guard   
u0:62 | field | block#62
u0:63 | func  | check   
u0:64 | call  | block#64

--- expect:graph ---
digraph project {
}




===============================================================================
if-let-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Dish;
fn parse() {
  let dish_opt = Some(Dish);
  if let Some(dish) = dish_opt {
  }

  if let Some("chained") = a && b && let (C, D) = e {
  }

  if foo && let bar = || baz && quux {}
  if a && let b = || c || d && e {}
}

--- expect:symbols ---
u0:1 | Module   | main     | main     | [global]
u0:2 | File     | main     | main     |         
u0:3 | Struct   | Dish     | Dish     |         
u0:4 | Function | parse    | parse    |         
u0:5 | Variable | dish_opt | dish_opt |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:65 | root  | main    
u0:66 | class | Dish    
u0:67 | func  | parse   
u0:68 | call  | block#68

--- expect:block-deps ---


--- expect:graph ---
digraph project {
}




===============================================================================
while-let-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Queue {
  items: Option<Vec<i32>>,
}

fn process() {
  let queue = Queue { items: Some(vec![]) };
  while let Some(items) = queue.items {
    let _ = items;
  }
}

--- expect:symbols ---
u0:1 | Module   | main    | main    | [global]
u0:2 | File     | main    | main    |         
u0:3 | Struct   | Queue   | Queue   |         
u0:4 | Field    | items   | items   |         
u0:5 | Function | process | process |         
u0:6 | Variable | queue   | queue   |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:69 | root  | main    
u0:70 | class | Queue   
u0:71 | field | block#71
u0:72 | func  | process 
u0:73 | call  | block#73

--- expect:graph ---
digraph project {
}




===============================================================================
match-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Value;

fn process_value() {
  let val = Value;
  match val {
    _ => {},
  }
}

--- expect:symbols ---
u0:1 | Module   | main          | main          | [global]
u0:2 | File     | main          | main          |         
u0:3 | Struct   | Value         | Value         |         
u0:4 | Function | process_value | process_value |         
u0:5 | Variable | val           | val           |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:74 | root  | main         
u0:75 | class | Value        
u0:76 | func  | process_value

--- expect:graph ---
digraph project {
}




===============================================================================
while-expressions
===============================================================================


--- file: app/src/main.rs ---
struct State {
  done: bool,
}

fn loop_until() {
  let state = State { done: false };
  while !state.done {
    let _ = state.done;
  }
}

--- expect:symbols ---
u0:1 | Module   | main       | main       | [global]
u0:2 | File     | main       | main       |         
u0:3 | Struct   | State      | State      |         
u0:4 | Field    | done       | done       |         
u0:5 | Function | loop_until | loop_until |         
u0:6 | Variable | state      | state      |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:77 | root  | main      
u0:78 | class | State     
u0:79 | field | block#79  
u0:80 | func  | loop_until

--- expect:graph ---
digraph project {
}




===============================================================================
loop-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Counter {
  limit: i32,
}

fn count() {
  let counter = Counter { limit: 10 };
  'outer: loop {
    'inner: loop {
      break 'outer;
    }
  }
}

--- expect:symbols ---
u0:1 | Module   | main    | main    | [global]
u0:2 | File     | main    | main    |         
u0:3 | Struct   | Counter | Counter |         
u0:4 | Field    | limit   | limit   |         
u0:5 | Function | count   | count   |         
u0:6 | Variable | counter | counter |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:81 | root  | main    
u0:82 | class | Counter 
u0:83 | field | block#83
u0:84 | func  | count   

--- expect:graph ---
digraph project {
}




===============================================================================
for-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Container;

fn iterate() {
  let container = Container;
  for i in 0..10 {
    let _ = i;
  }
}

--- expect:symbols ---
u0:1 | Module   | main      | main      | [global]
u0:2 | File     | main      | main      |         
u0:3 | Struct   | Container | Container |         
u0:4 | Function | iterate   | iterate   |         
u0:5 | Variable | container | container |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:85 | root  | main     
u0:86 | class | Container
u0:87 | func  | iterate  

--- expect:graph ---
digraph project {
}




===============================================================================
field-expressions
===============================================================================


--- file: app/src/main.rs ---
struct Foo;
struct Far;
struct Baz {
  x: Far,
}

struct MyStruct {
  myfield: Foo,
}

fn foo() -> Baz {
  Baz
}

fn bar() {
  let mystruct = MyStruct { myfield: Foo };
  let x = mystruct.myfield;
  let y = foo().x;
  value.0.1.iter();
  1.max(2);
}

--- expect:symbols ---
u0:1  | Module   | main     | main     | [global]
u0:2  | File     | main     | main     |         
u0:3  | Struct   | Foo      | Foo      |         
u0:4  | Struct   | Far      | Far      |         
u0:5  | Struct   | Baz      | Baz      |         
u0:6  | Field    | x        | x        |         
u0:7  | Struct   | MyStruct | MyStruct |         
u0:8  | Field    | myfield  | myfield  |         
u0:9  | Function | foo      | foo      |         
u0:10 | Function | bar      | bar      |         
u0:11 | Variable | mystruct | mystruct |         
u0:12 | Variable | x        | x        |         
u0:13 | Variable | y        | y        |         

--- expect:symbol-deps ---
u0:3 <- [u0:8]
u0:4 <- [u0:6]
u0:6 -> [u0:4]
u0:8 -> [u0:3]

--- expect:blocks ---
u0:88 | root  | main    
u0:89 | class | Foo     
u0:90 | class | Far     
u0:91 | class | Baz     
u0:92 | field | block#92
u0:93 | class | MyStruct
u0:94 | field | block#94
u0:95 | func  | foo     
u0:96 | func  | bar     
u0:97 | call  | block#97
u0:98 | call  | block#98
u0:99 | call  | block#99

--- expect:block-deps ---


--- expect:graph ---
digraph project {
}




===============================================================================
method-call-expressions
===============================================================================


--- file: src/main.rs ---
struct Foo;

struct MyStruct;

impl MyStruct {
  fn foo(&self) -> Foo {}
}

fn func() {
    let mystruct = MyStruct::new();
    let x = mystruct.foo();
}

--- expect:symbols ---
u0:1 | Module   | main          | main          | [global]
u0:2 | File     | main          | main          |         
u0:3 | Struct   | Foo           | Foo           |         
u0:4 | Struct   | MyStruct      | MyStruct      |         
u0:5 | Impl     | impl MyStruct | impl MyStruct |         
u0:6 | Function | foo           | foo           |         
u0:7 | Function | func          | func          |         
u0:8 | Variable | mystruct      | mystruct      |         
u0:9 | Variable | x             | x             |         

--- expect:symbol-deps ---
u0:4 <- [u0:5]
u0:5 -> [u0:4]




===============================================================================
index-expressions
===============================================================================


--- file: src/main.rs ---
([1, 2, 3, 4])[0];
arr[10];
arr[n];

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         




===============================================================================
scoped-functions
===============================================================================


--- file: app/src/foo.rs ---
pub fn f() {}

pub mod g {
  pub fn h() {}
}

--- file: app/src/main.rs ---
struct a;
impl a {
  fn b() {}
}

struct C;
impl C {
  fn e() {}
}

fn foo() {
  a::b();
  C::<D>::e();
  ::f();
  ::g::h();
}

--- expect:symbols ---
u0:1  | Module    | foo    | foo    | [global]
u0:3  | File      | foo    | foo    |         
u0:5  | Function  | f      | f      |         
u0:7  | Namespace | g      | g      |         
u0:9  | Function  | h      | h      |         
u1:2  | Module    | main   | main   | [global]
u1:4  | File      | main   | main   |         
u1:6  | Struct    | a      | a      |         
u1:8  | Impl      | impl a | impl a |         
u1:10 | Function  | b      | b      |         
u1:11 | Struct    | C      | C      |         
u1:12 | Impl      | impl C | impl C |         
u1:13 | Function  | e      | e      |         
u1:14 | Function  | foo    | foo    |         

--- expect:symbol-deps ---
u1:11 <- [u1:12]
u1:12 -> [u1:11]
u1:6 <- [u1:8]
u1:8 -> [u1:6]

--- expect:block-graph ---
(root:100 foo
    (func:101 f)
    (func:104 h)
)

(root:102 main
    (class:103 a)
    (impl:105 impl a
        (method:106 b)
    )
    (class:107 C)
    (impl:108 impl C
        (method:109 e)
    )
    (func:110 foo
        (call:111)
        (call:112)
        (call:113)
        (call:114)
    )
)

--- expect:block-deps ---
u1:103 <- [u1:105]
u1:105 -> [u1:103]
u1:107 <- [u1:108]
u1:108 -> [u1:107]


===============================================================================
scoped-functions-with-fully-qualified-syntax
===============================================================================


--- file: src/main.rs ---
<Dog as Animal>::eat(d);

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         




===============================================================================
scoped-functions-with-macros-as-types
===============================================================================


--- file: src/main.rs ---
<Token![]>::foo();

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         




===============================================================================
scoped-identifier-with-nested-super
===============================================================================


--- file: src/main.rs ---
pub fn foo() {}
pub mod m1 {
  mod m2 {
    fn bar() {
      super::super::foo();
    }
}


--- expect:symbols ---
u0:1 | Module    | main | main | [global]
u0:2 | File      | main | main |         
u0:3 | Function  | foo  | foo  |         
u0:4 | Namespace | m1   | m1   |         
u0:5 | Namespace | m2   | m2   |         
u0:6 | Function  | bar  | bar  |         

--- expect:symbol-deps ---


--- expect:blocks ---
u0:115 | root | main     
u0:116 | func | foo      
u0:117 | func | bar      
u0:118 | call | block#118


===============================================================================
generic-functions
===============================================================================


--- file: src/main.rs ---
std::sizeof::<u32>();
foo::<8>();

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         




===============================================================================
closures
===============================================================================


--- file: src/main.rs ---
a.map(|(b, c)| b.push(c));
d.map(move |mut e| {
    f(e);
    g(e)
});
h(|| -> i { j });

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         




===============================================================================
closures-with-typed-parameteres
===============================================================================


--- file: src/main.rs ---
a.map(|b: usize| b.push(c));

--- expect:symbols ---
u0:1 | Module   | main | main | [global]
u0:2 | File     | main | main |         
u0:3 | Variable | b    | b    |         




===============================================================================
generators
===============================================================================


--- file: src/main.rs ---
move || {
    while i <= n {
        yield i;
        i += 1;
    }
    return;
};

--- expect:symbols ---
u0:1 | Module | main | main | [global]
u0:2 | File   | main | main |         




===============================================================================
unsafe-blocks
===============================================================================


--- file: src/main.rs ---
fn foo() {}
const a : A = unsafe { foo() };

--- expect:symbols ---
u0:1 | Module   | main | main | [global]
u0:2 | File     | main | main |         
u0:3 | Function | foo  | foo  |         
u0:4 | Const    | a    | a    |         

--- expect:symbol-deps ---





===============================================================================
inline-const-or-const-blocks-as-expression
===============================================================================


--- file: src/main.rs ---
const { 1 + 3 };
if *x < 0 { const { &4i32.pow(4) } } else { x }
let three_ranges = [const { (0..=5).into_inner() }; 3];

--- expect:symbols ---
u0:1 | Module   | main         | main         | [global]
u0:2 | File     | main         | main         |         
u0:3 | Variable | three_ranges | three_ranges |         




===============================================================================
raw-reference-expression-conflicts
===============================================================================


--- file: src/main.rs ---
some_call(&raw);
let a = &raw const b;

--- expect:symbols ---
u0:1 | Module   | main | main | [global]
u0:2 | File     | main | main |         
u0:3 | Variable | a    | a    |         

