===============================================================================
layered-architecture-basic
===============================================================================
Tests 3-layer architecture: data layer (entities/repository), service layer (business logic), api layer (handlers).

--- file: src/lib.rs ---
pub mod data;
pub mod service;
pub mod api;

--- file: src/data/mod.rs ---
mod entity;
mod repository;

pub use entity::User;
pub use repository::UserRepository;

--- file: src/data/entity.rs ---
#[derive(Clone, Debug)]
pub struct User {
    pub id: u64,
    pub email: String,
    pub password_hash: String,
}

--- file: src/data/repository.rs ---
use super::entity::User;
use std::collections::HashMap;

pub struct UserRepository {
    storage: HashMap<u64, User>,
    next_id: u64,
}

impl UserRepository {
    pub fn new() -> Self {
        UserRepository { storage: HashMap::new(), next_id: 1 }
    }

    pub fn find_by_id(&self, id: u64) -> Option<User> {
        self.storage.get(&id).cloned()
    }

    pub fn find_by_email(&self, email: &str) -> Option<User> {
        self.storage.values().find(|u| u.email == email).cloned()
    }

    pub fn insert(&mut self, email: String, password_hash: String) -> User {
        let user = User { id: self.next_id, email, password_hash };
        self.next_id += 1;
        self.storage.insert(user.id, user.clone());
        user
    }
}

--- file: src/service/mod.rs ---
mod user_service;
mod auth_service;

pub use user_service::UserService;
pub use auth_service::AuthService;

--- file: src/service/user_service.rs ---
use crate::data::{User, UserRepository};

pub struct UserService {
    repo: UserRepository,
}

impl UserService {
    pub fn new(repo: UserRepository) -> Self {
        UserService { repo }
    }

    pub fn get_user(&self, id: u64) -> Option<User> {
        self.repo.find_by_id(id)
    }

    pub fn create_user(&mut self, email: String, password: String) -> User {
        let hash = format!("hashed:{}", password);  // Simplified
        self.repo.insert(email, hash)
    }
}

--- file: src/service/auth_service.rs ---
use crate::data::{User, UserRepository};

pub struct AuthService {
    repo: UserRepository,
}

impl AuthService {
    pub fn new(repo: UserRepository) -> Self {
        AuthService { repo }
    }

    pub fn authenticate(&self, email: &str, password: &str) -> Option<User> {
        let user = self.repo.find_by_email(email)?;
        let expected_hash = format!("hashed:{}", password);
        if user.password_hash == expected_hash {
            Some(user)
        } else {
            None
        }
    }
}

--- file: src/api/mod.rs ---
mod handlers;
mod dto;

pub use handlers::*;
pub use dto::*;

--- file: src/api/dto.rs ---
use crate::data::User;

pub struct UserDto {
    pub id: u64,
    pub email: String,
}

impl From<User> for UserDto {
    fn from(user: User) -> Self {
        UserDto { id: user.id, email: user.email }
    }
}

pub struct CreateUserRequest {
    pub email: String,
    pub password: String,
}

pub struct LoginRequest {
    pub email: String,
    pub password: String,
}

--- file: src/api/handlers.rs ---
use crate::service::{UserService, AuthService};
use super::dto::{UserDto, CreateUserRequest, LoginRequest};

pub fn handle_get_user(service: &UserService, id: u64) -> Option<UserDto> {
    service.get_user(id).map(UserDto::from)
}

pub fn handle_create_user(service: &mut UserService, req: CreateUserRequest) -> UserDto {
    let user = service.create_user(req.email, req.password);
    UserDto::from(user)
}

pub fn handle_login(service: &AuthService, req: LoginRequest) -> Option<UserDto> {
    service.authenticate(&req.email, &req.password).map(UserDto::from)
}

--- file: src/main.rs ---
mod data;
mod service;
mod api;

use data::UserRepository;
use service::{UserService, AuthService};
use api::{handle_create_user, handle_get_user, CreateUserRequest};

fn main() {
    let repo = UserRepository::new();
    let mut user_service = UserService::new(repo);

    let req = CreateUserRequest {
        email: "alice@example.com".to_string(),
        password: "secret".to_string(),
    };

    let created = handle_create_user(&mut user_service, req);
    println!("Created user: {} (id={})", created.email, created.id);

    if let Some(found) = handle_get_user(&user_service, created.id) {
        println!("Found user: {}", found.email);
    }
}


--- expect:dep-graph ---
digraph project {
  graph [fontname="Helvetica Bold", fontsize=12];

  subgraph cluster_0 {
    label="_c";
    subgraph cluster_1 {
      label="api";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n9[label="CreateUserRequest", full_path="$TMP/src/api/dto.rs:14"];
      n10[label="LoginRequest", full_path="$TMP/src/api/dto.rs:19"];
      n6[label="UserDto", full_path="$TMP/src/api/dto.rs:3"];
      n14[label="handle_login", full_path="$TMP/src/api/handlers.rs:13"];
      n12[label="handle_get_user", full_path="$TMP/src/api/handlers.rs:4"];
      n13[label="handle_create_user", full_path="$TMP/src/api/handlers.rs:8"];
    }
    subgraph cluster_2 {
      label="data";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n17[label="User", full_path="$TMP/src/data/entity.rs:2"];
      n19[label="UserRepository", full_path="$TMP/src/data/repository.rs:4"];
    }
    subgraph cluster_3 {
      label="main";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n3[label="main", full_path="$TMP/src/main.rs:9"];
    }
    subgraph cluster_4 {
      label="service";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n33[label="AuthService", full_path="$TMP/src/service/auth_service.rs:3"];
      n27[label="UserService", full_path="$TMP/src/service/user_service.rs:3"];
    }
  }
  n33 -> n19;
  n19 -> n17;
  n27 -> n19;
  n13 -> n9;
  n13 -> n6;
  n13 -> n27;
  n12 -> n27;
  n14 -> n33;
  n14 -> n10;
  n3 -> n9;
  n3 -> n19;
  n3 -> n27;
  n3 -> n13;
  n3 -> n12;
}

--- expect:arch-graph ---
digraph architecture {
  graph [fontname="Helvetica Bold", fontsize=12];

  subgraph cluster_0 {
    label="_c";
    subgraph cluster_1 {
      label="api";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n9[label="CreateUserRequest", full_path="$TMP/src/api/dto.rs:14", sym_ty="Struct", shape=box];
      n10[label="LoginRequest", full_path="$TMP/src/api/dto.rs:19", sym_ty="Struct", shape=box];
      n6[label="UserDto", full_path="$TMP/src/api/dto.rs:3", sym_ty="Struct", shape=box];
      n14[label="handle_login", full_path="$TMP/src/api/handlers.rs:13", sym_ty="Function"];
      n12[label="handle_get_user", full_path="$TMP/src/api/handlers.rs:4", sym_ty="Function"];
      n13[label="handle_create_user", full_path="$TMP/src/api/handlers.rs:8", sym_ty="Function"];
    }
    subgraph cluster_2 {
      label="data";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n17[label="User", full_path="$TMP/src/data/entity.rs:2", sym_ty="Struct", shape=box];
      n19[label="UserRepository", full_path="$TMP/src/data/repository.rs:4", sym_ty="Struct", shape=box];
    }
    subgraph cluster_3 {
      label="main";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n3[label="main", full_path="$TMP/src/main.rs:9", sym_ty="Function"];
    }
    subgraph cluster_4 {
      label="service";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n33[label="AuthService", full_path="$TMP/src/service/auth_service.rs:3", sym_ty="Struct", shape=box];
      n27[label="UserService", full_path="$TMP/src/service/user_service.rs:3", sym_ty="Struct", shape=box];
    }
  }
  n33 -> n19 [from="struct", to="field"];
  n33 -> n14 [from="input", to="func"];
  n9 -> n13 [from="input", to="func"];
  n10 -> n14 [from="input", to="func"];
  n19 -> n17 [from="struct", to="field"];
  n27 -> n19 [from="struct", to="field"];
  n27 -> n13 [from="input", to="func"];
  n27 -> n12 [from="input", to="func"];
  n13 -> n6 [from="user", to="used"];
  n3 -> n9 [from="user", to="used"];
  n3 -> n19 [from="user", to="used"];
  n3 -> n27 [from="user", to="used"];
  n3 -> n13 [from="caller", to="callee"];
  n3 -> n12 [from="caller", to="callee"];
}


===============================================================================
hexagonal-architecture
===============================================================================
Tests hexagonal (ports & adapters) architecture: domain core, ports (traits), adapters (implementations).

--- file: src/lib.rs ---
pub mod domain;
pub mod ports;
pub mod adapters;
pub mod application;

--- file: src/domain/mod.rs ---
mod order;
mod product;

pub use order::{Order, OrderStatus};
pub use product::Product;

--- file: src/domain/product.rs ---
#[derive(Clone)]
pub struct Product {
    pub id: u64,
    pub name: String,
    pub price: f64,
    pub stock: u32,
}

--- file: src/domain/order.rs ---
use super::product::Product;

#[derive(Clone, PartialEq)]
pub enum OrderStatus {
    Pending,
    Confirmed,
    Shipped,
    Delivered,
}

#[derive(Clone)]
pub struct Order {
    pub id: u64,
    pub products: Vec<(Product, u32)>,  // (product, quantity)
    pub status: OrderStatus,
}

impl Order {
    pub fn new(id: u64) -> Self {
        Order { id, products: Vec::new(), status: OrderStatus::Pending }
    }

    pub fn add_product(&mut self, product: Product, quantity: u32) {
        self.products.push((product, quantity));
    }

    pub fn total(&self) -> f64 {
        self.products.iter().map(|(p, q)| p.price * *q as f64).sum()
    }

    pub fn confirm(&mut self) {
        self.status = OrderStatus::Confirmed;
    }
}

--- file: src/ports/mod.rs ---
mod inbound;
mod outbound;

pub use inbound::*;
pub use outbound::*;

--- file: src/ports/inbound.rs ---
use crate::domain::{Order, Product};

// Inbound port - what the application offers
pub trait OrderUseCase {
    fn create_order(&mut self) -> Order;
    fn add_to_order(&mut self, order_id: u64, product_id: u64, quantity: u32) -> bool;
    fn confirm_order(&mut self, order_id: u64) -> bool;
    fn get_order(&self, order_id: u64) -> Option<Order>;
}

pub trait ProductUseCase {
    fn get_product(&self, id: u64) -> Option<Product>;
    fn list_products(&self) -> Vec<Product>;
}

--- file: src/ports/outbound.rs ---
use crate::domain::{Order, Product};

// Outbound port - what the application needs
pub trait OrderRepository {
    fn save(&mut self, order: Order) -> u64;
    fn find_by_id(&self, id: u64) -> Option<Order>;
    fn update(&mut self, order: Order) -> bool;
}

pub trait ProductRepository {
    fn find_by_id(&self, id: u64) -> Option<Product>;
    fn find_all(&self) -> Vec<Product>;
}

pub trait NotificationService {
    fn notify_order_confirmed(&self, order: &Order);
}

--- file: src/adapters/mod.rs ---
mod memory_order_repo;
mod memory_product_repo;
mod email_notification;

pub use memory_order_repo::InMemoryOrderRepo;
pub use memory_product_repo::InMemoryProductRepo;
pub use email_notification::EmailNotification;

--- file: src/adapters/memory_order_repo.rs ---
use crate::domain::Order;
use crate::ports::OrderRepository;
use std::collections::HashMap;

pub struct InMemoryOrderRepo {
    orders: HashMap<u64, Order>,
    next_id: u64,
}

impl InMemoryOrderRepo {
    pub fn new() -> Self {
        InMemoryOrderRepo { orders: HashMap::new(), next_id: 1 }
    }
}

impl OrderRepository for InMemoryOrderRepo {
    fn save(&mut self, mut order: Order) -> u64 {
        order.id = self.next_id;
        self.next_id += 1;
        let id = order.id;
        self.orders.insert(id, order);
        id
    }

    fn find_by_id(&self, id: u64) -> Option<Order> {
        self.orders.get(&id).cloned()
    }

    fn update(&mut self, order: Order) -> bool {
        if self.orders.contains_key(&order.id) {
            self.orders.insert(order.id, order);
            true
        } else {
            false
        }
    }
}

--- file: src/adapters/memory_product_repo.rs ---
use crate::domain::Product;
use crate::ports::ProductRepository;
use std::collections::HashMap;

pub struct InMemoryProductRepo {
    products: HashMap<u64, Product>,
}

impl InMemoryProductRepo {
    pub fn new() -> Self {
        let mut products = HashMap::new();
        products.insert(1, Product { id: 1, name: "Widget".to_string(), price: 9.99, stock: 100 });
        products.insert(2, Product { id: 2, name: "Gadget".to_string(), price: 19.99, stock: 50 });
        InMemoryProductRepo { products }
    }
}

impl ProductRepository for InMemoryProductRepo {
    fn find_by_id(&self, id: u64) -> Option<Product> {
        self.products.get(&id).cloned()
    }

    fn find_all(&self) -> Vec<Product> {
        self.products.values().cloned().collect()
    }
}

--- file: src/adapters/email_notification.rs ---
use crate::domain::Order;
use crate::ports::NotificationService;

pub struct EmailNotification;

impl NotificationService for EmailNotification {
    fn notify_order_confirmed(&self, order: &Order) {
        println!("Email: Order {} confirmed, total: ${:.2}", order.id, order.total());
    }
}

--- file: src/application/mod.rs ---
mod order_service;

pub use order_service::OrderService;

--- file: src/application/order_service.rs ---
use crate::domain::Order;
use crate::ports::{OrderUseCase, OrderRepository, ProductRepository, NotificationService};

pub struct OrderService<O: OrderRepository, P: ProductRepository, N: NotificationService> {
    order_repo: O,
    product_repo: P,
    notification: N,
}

impl<O: OrderRepository, P: ProductRepository, N: NotificationService> OrderService<O, P, N> {
    pub fn new(order_repo: O, product_repo: P, notification: N) -> Self {
        OrderService { order_repo, product_repo, notification }
    }
}

impl<O: OrderRepository, P: ProductRepository, N: NotificationService> OrderUseCase for OrderService<O, P, N> {
    fn create_order(&mut self) -> Order {
        let order = Order::new(0);
        let id = self.order_repo.save(order);
        self.order_repo.find_by_id(id).unwrap()
    }

    fn add_to_order(&mut self, order_id: u64, product_id: u64, quantity: u32) -> bool {
        let product = match self.product_repo.find_by_id(product_id) {
            Some(p) => p,
            None => return false,
        };

        let mut order = match self.order_repo.find_by_id(order_id) {
            Some(o) => o,
            None => return false,
        };

        order.add_product(product, quantity);
        self.order_repo.update(order)
    }

    fn confirm_order(&mut self, order_id: u64) -> bool {
        let mut order = match self.order_repo.find_by_id(order_id) {
            Some(o) => o,
            None => return false,
        };

        order.confirm();
        self.notification.notify_order_confirmed(&order);
        self.order_repo.update(order)
    }

    fn get_order(&self, order_id: u64) -> Option<Order> {
        self.order_repo.find_by_id(order_id)
    }
}

--- file: src/main.rs ---
mod domain;
mod ports;
mod adapters;
mod application;

use adapters::{InMemoryOrderRepo, InMemoryProductRepo, EmailNotification};
use application::OrderService;
use ports::OrderUseCase;

fn main() {
    let order_repo = InMemoryOrderRepo::new();
    let product_repo = InMemoryProductRepo::new();
    let notification = EmailNotification;

    let mut service = OrderService::new(order_repo, product_repo, notification);

    let order = service.create_order();
    service.add_to_order(order.id, 1, 2);  // 2 Widgets
    service.add_to_order(order.id, 2, 1);  // 1 Gadget
    service.confirm_order(order.id);

    if let Some(confirmed) = service.get_order(order.id) {
        println!("Order {} confirmed, total: ${:.2}", confirmed.id, confirmed.total());
    }
}

--- expect:dep-graph ---
digraph project {
  graph [fontname="Helvetica Bold", fontsize=12];

  subgraph cluster_0 {
    label="_c";
    subgraph cluster_1 {
      label="adapters";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n21[label="EmailNotification", full_path="$TMP/src/adapters/email_notification.rs:4"];
      n6[label="InMemoryOrderRepo", full_path="$TMP/src/adapters/memory_order_repo.rs:5"];
      n14[label="InMemoryProductRepo", full_path="$TMP/src/adapters/memory_product_repo.rs:5"];
    }
    subgraph cluster_2 {
      label="application";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n26[label="OrderService", full_path="$TMP/src/application/order_service.rs:4"];
    }
    subgraph cluster_3 {
      label="domain";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n39[label="Order", full_path="$TMP/src/domain/order.rs:12"];
      n38[label="OrderStatus", full_path="$TMP/src/domain/order.rs:4"];
      n36[label="Product", full_path="$TMP/src/domain/product.rs:2"];
    }
    subgraph cluster_4 {
      label="main";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n3[label="main", full_path="$TMP/src/main.rs:10"];
    }
    subgraph cluster_5 {
      label="ports";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n52[label="ProductUseCase", full_path="$TMP/src/ports/inbound.rs:11"];
      n47[label="OrderUseCase", full_path="$TMP/src/ports/inbound.rs:4"];
      n60[label="ProductRepository", full_path="$TMP/src/ports/outbound.rs:10"];
      n63[label="NotificationService", full_path="$TMP/src/ports/outbound.rs:15"];
      n56[label="OrderRepository", full_path="$TMP/src/ports/outbound.rs:4"];
    }
  }
  n21 -> n63;
  n6 -> n39;
  n6 -> n56;
  n14 -> n36;
  n14 -> n60;
  n39 -> n38;
  n39 -> n36;
  n26 -> n63;
  n26 -> n56;
  n26 -> n47;
  n26 -> n60;
  n3 -> n21;
  n3 -> n6;
  n3 -> n14;
  n3 -> n26;
}

--- expect:arch-graph ---
digraph architecture {
  graph [fontname="Helvetica Bold", fontsize=12];

  subgraph cluster_0 {
    label="_c";
    subgraph cluster_1 {
      label="adapters";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n21[label="EmailNotification", full_path="$TMP/src/adapters/email_notification.rs:4", sym_ty="Struct", shape=box];
      n6[label="InMemoryOrderRepo", full_path="$TMP/src/adapters/memory_order_repo.rs:5", sym_ty="Struct", shape=box];
      n14[label="InMemoryProductRepo", full_path="$TMP/src/adapters/memory_product_repo.rs:5", sym_ty="Struct", shape=box];
    }
    subgraph cluster_2 {
      label="application";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n26[label="OrderService", full_path="$TMP/src/application/order_service.rs:4", sym_ty="Struct", shape=box];
    }
    subgraph cluster_3 {
      label="domain";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n39[label="Order", full_path="$TMP/src/domain/order.rs:12", sym_ty="Struct", shape=box];
      n38[label="OrderStatus", full_path="$TMP/src/domain/order.rs:4", sym_ty="Enum", shape=box];
      n36[label="Product", full_path="$TMP/src/domain/product.rs:2", sym_ty="Struct", shape=box];
    }
    subgraph cluster_4 {
      label="main";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n3[label="main", full_path="$TMP/src/main.rs:10", sym_ty="Function"];
    }
    subgraph cluster_5 {
      label="ports";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n52[label="ProductUseCase", full_path="$TMP/src/ports/inbound.rs:11", sym_ty="Trait", shape=box];
      n47[label="OrderUseCase", full_path="$TMP/src/ports/inbound.rs:4", sym_ty="Trait", shape=box];
      n60[label="ProductRepository", full_path="$TMP/src/ports/outbound.rs:10", sym_ty="Trait", shape=box];
      n63[label="NotificationService", full_path="$TMP/src/ports/outbound.rs:15", sym_ty="Trait", shape=box];
      n56[label="OrderRepository", full_path="$TMP/src/ports/outbound.rs:4", sym_ty="Trait", shape=box];
    }
  }
  n6 -> n39 [from="struct", to="field"];
  n14 -> n36 [from="struct", to="field"];
  n63 -> n21 [from="trait", to="impl"];
  n63 -> n26 [from="bound", to="generic"];
  n39 -> n38 [from="struct", to="field"];
  n39 -> n36 [from="struct", to="field"];
  n56 -> n6 [from="trait", to="impl"];
  n56 -> n26 [from="bound", to="generic"];
  n47 -> n26 [from="trait", to="impl"];
  n60 -> n14 [from="trait", to="impl"];
  n60 -> n26 [from="bound", to="generic"];
  n3 -> n21 [from="user", to="used"];
  n3 -> n6 [from="user", to="used"];
  n3 -> n14 [from="user", to="used"];
  n3 -> n26 [from="user", to="used"];
}


===============================================================================
clean-architecture
===============================================================================
Tests clean architecture: entities (core), use_cases (app logic), interface_adapters, frameworks (external).

--- file: src/lib.rs ---
pub mod entities;
pub mod use_cases;
pub mod interface_adapters;
pub mod frameworks;

--- file: src/entities/mod.rs ---
mod task;

pub use task::{Task, TaskStatus, Priority};

--- file: src/entities/task.rs ---
#[derive(Clone, PartialEq)]
pub enum TaskStatus {
    Todo,
    InProgress,
    Done,
}

#[derive(Clone, PartialEq, PartialOrd)]
pub enum Priority {
    Low,
    Medium,
    High,
}

#[derive(Clone)]
pub struct Task {
    pub id: u64,
    pub title: String,
    pub description: Option<String>,
    pub status: TaskStatus,
    pub priority: Priority,
}

impl Task {
    pub fn new(id: u64, title: String, priority: Priority) -> Self {
        Task {
            id,
            title,
            description: None,
            status: TaskStatus::Todo,
            priority,
        }
    }

    pub fn start(&mut self) {
        self.status = TaskStatus::InProgress;
    }

    pub fn complete(&mut self) {
        self.status = TaskStatus::Done;
    }

    pub fn is_done(&self) -> bool {
        self.status == TaskStatus::Done
    }
}

--- file: src/use_cases/mod.rs ---
mod task_use_cases;
mod ports;

pub use task_use_cases::*;
pub use ports::*;

--- file: src/use_cases/ports.rs ---
use crate::entities::Task;

// Output port - use case boundary
pub trait TaskGateway {
    fn save(&mut self, task: Task) -> u64;
    fn find_by_id(&self, id: u64) -> Option<Task>;
    fn find_all(&self) -> Vec<Task>;
    fn update(&mut self, task: Task) -> bool;
    fn delete(&mut self, id: u64) -> bool;
}

pub trait TaskPresenter {
    fn present_task(&self, task: &Task);
    fn present_task_list(&self, tasks: &[Task]);
    fn present_error(&self, message: &str);
}

--- file: src/use_cases/task_use_cases.rs ---
use crate::entities::{Task, Priority};
use super::ports::{TaskGateway, TaskPresenter};

pub struct CreateTaskUseCase<'a, G: TaskGateway, P: TaskPresenter> {
    gateway: &'a mut G,
    presenter: &'a P,
}

impl<'a, G: TaskGateway, P: TaskPresenter> CreateTaskUseCase<'a, G, P> {
    pub fn new(gateway: &'a mut G, presenter: &'a P) -> Self {
        CreateTaskUseCase { gateway, presenter }
    }

    pub fn execute(&mut self, title: String, priority: Priority) {
        let task = Task::new(0, title, priority);
        let id = self.gateway.save(task);
        if let Some(created) = self.gateway.find_by_id(id) {
            self.presenter.present_task(&created);
        }
    }
}

pub struct CompleteTaskUseCase<'a, G: TaskGateway, P: TaskPresenter> {
    gateway: &'a mut G,
    presenter: &'a P,
}

impl<'a, G: TaskGateway, P: TaskPresenter> CompleteTaskUseCase<'a, G, P> {
    pub fn new(gateway: &'a mut G, presenter: &'a P) -> Self {
        CompleteTaskUseCase { gateway, presenter }
    }

    pub fn execute(&mut self, task_id: u64) {
        match self.gateway.find_by_id(task_id) {
            Some(mut task) => {
                task.complete();
                self.gateway.update(task.clone());
                self.presenter.present_task(&task);
            }
            None => {
                self.presenter.present_error("Task not found");
            }
        }
    }
}

pub struct ListTasksUseCase<'a, G: TaskGateway, P: TaskPresenter> {
    gateway: &'a G,
    presenter: &'a P,
}

impl<'a, G: TaskGateway, P: TaskPresenter> ListTasksUseCase<'a, G, P> {
    pub fn new(gateway: &'a G, presenter: &'a P) -> Self {
        ListTasksUseCase { gateway, presenter }
    }

    pub fn execute(&self) {
        let tasks = self.gateway.find_all();
        self.presenter.present_task_list(&tasks);
    }
}

--- file: src/interface_adapters/mod.rs ---
mod memory_gateway;
mod console_presenter;

pub use memory_gateway::InMemoryTaskGateway;
pub use console_presenter::ConsolePresenter;

--- file: src/interface_adapters/memory_gateway.rs ---
use crate::entities::Task;
use crate::use_cases::TaskGateway;
use std::collections::HashMap;

pub struct InMemoryTaskGateway {
    tasks: HashMap<u64, Task>,
    next_id: u64,
}

impl InMemoryTaskGateway {
    pub fn new() -> Self {
        InMemoryTaskGateway { tasks: HashMap::new(), next_id: 1 }
    }
}

impl TaskGateway for InMemoryTaskGateway {
    fn save(&mut self, mut task: Task) -> u64 {
        task.id = self.next_id;
        self.next_id += 1;
        let id = task.id;
        self.tasks.insert(id, task);
        id
    }

    fn find_by_id(&self, id: u64) -> Option<Task> {
        self.tasks.get(&id).cloned()
    }

    fn find_all(&self) -> Vec<Task> {
        self.tasks.values().cloned().collect()
    }

    fn update(&mut self, task: Task) -> bool {
        if self.tasks.contains_key(&task.id) {
            self.tasks.insert(task.id, task);
            true
        } else {
            false
        }
    }

    fn delete(&mut self, id: u64) -> bool {
        self.tasks.remove(&id).is_some()
    }
}

--- file: src/interface_adapters/console_presenter.rs ---
use crate::entities::Task;
use crate::use_cases::TaskPresenter;

pub struct ConsolePresenter;

impl TaskPresenter for ConsolePresenter {
    fn present_task(&self, task: &Task) {
        println!("Task #{}: {} [{:?}]", task.id, task.title, task.status);
    }

    fn present_task_list(&self, tasks: &[Task]) {
        println!("=== Tasks ({}) ===", tasks.len());
        for task in tasks {
            self.present_task(task);
        }
    }

    fn present_error(&self, message: &str) {
        eprintln!("Error: {}", message);
    }
}

--- file: src/main.rs ---
mod entities;
mod use_cases;
mod interface_adapters;

use entities::Priority;
use use_cases::{CreateTaskUseCase, CompleteTaskUseCase, ListTasksUseCase};
use interface_adapters::{InMemoryTaskGateway, ConsolePresenter};

fn main() {
    let mut gateway = InMemoryTaskGateway::new();
    let presenter = ConsolePresenter;

    // Create tasks
    {
        let mut create = CreateTaskUseCase::new(&mut gateway, &presenter);
        create.execute("Learn Rust".to_string(), Priority::High);
        create.execute("Write tests".to_string(), Priority::Medium);
        create.execute("Deploy app".to_string(), Priority::Low);
    }

    // Complete first task
    {
        let mut complete = CompleteTaskUseCase::new(&mut gateway, &presenter);
        complete.execute(1);
    }

    // List all tasks
    {
        let list = ListTasksUseCase::new(&gateway, &presenter);
        list.execute();
    }
}


--- expect:dep-graph ---
digraph project {
  graph [fontname="Helvetica Bold", fontsize=12];

  subgraph cluster_0 {
    label="_c";
    subgraph cluster_1 {
      label="entities";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n8[label="Task", full_path="$TMP/src/entities/task.rs:16"];
      n6[label="TaskStatus", full_path="$TMP/src/entities/task.rs:2"];
      n7[label="Priority", full_path="$TMP/src/entities/task.rs:9"];
    }
    subgraph cluster_2 {
      label="interface_adapters";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n26[label="ConsolePresenter", full_path="$TMP/src/interface_adapters/console_presenter.rs:4"];
      n16[label="InMemoryTaskGateway", full_path="$TMP/src/interface_adapters/memory_gateway.rs:5"];
    }
    subgraph cluster_3 {
      label="main";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n3[label="main", full_path="$TMP/src/main.rs:9"];
    }
    subgraph cluster_4 {
      label="use_cases";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n39[label="TaskPresenter", full_path="$TMP/src/use_cases/ports.rs:12"];
      n33[label="TaskGateway", full_path="$TMP/src/use_cases/ports.rs:4"];
      n48[label="CompleteTaskUseCase", full_path="$TMP/src/use_cases/task_use_cases.rs:23"];
      n44[label="CreateTaskUseCase", full_path="$TMP/src/use_cases/task_use_cases.rs:4"];
      n52[label="ListTasksUseCase", full_path="$TMP/src/use_cases/task_use_cases.rs:47"];
    }
  }
  n48 -> n33;
  n48 -> n39;
  n26 -> n39;
  n44 -> n33;
  n44 -> n39;
  n16 -> n8;
  n16 -> n33;
  n52 -> n33;
  n52 -> n39;
  n8 -> n7;
  n8 -> n6;
  n3 -> n48;
  n3 -> n26;
  n3 -> n44;
  n3 -> n16;
  n3 -> n52;
  n3 -> n7;
}

--- expect:arch-graph ---
digraph architecture {
  graph [fontname="Helvetica Bold", fontsize=12];

  subgraph cluster_0 {
    label="_c";
    subgraph cluster_1 {
      label="entities";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n8[label="Task", full_path="$TMP/src/entities/task.rs:16", sym_ty="Struct", shape=box];
      n6[label="TaskStatus", full_path="$TMP/src/entities/task.rs:2", sym_ty="Enum", shape=box];
      n7[label="Priority", full_path="$TMP/src/entities/task.rs:9", sym_ty="Enum", shape=box];
    }
    subgraph cluster_2 {
      label="interface_adapters";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n26[label="ConsolePresenter", full_path="$TMP/src/interface_adapters/console_presenter.rs:4", sym_ty="Struct", shape=box];
      n16[label="InMemoryTaskGateway", full_path="$TMP/src/interface_adapters/memory_gateway.rs:5", sym_ty="Struct", shape=box];
    }
    subgraph cluster_3 {
      label="main";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n3[label="main", full_path="$TMP/src/main.rs:9", sym_ty="Function"];
    }
    subgraph cluster_4 {
      label="use_cases";
      style="filled";
      fillcolor="#EEEEEE";
      color="#616161";
      n39[label="TaskPresenter", full_path="$TMP/src/use_cases/ports.rs:12", sym_ty="Trait", shape=box];
      n33[label="TaskGateway", full_path="$TMP/src/use_cases/ports.rs:4", sym_ty="Trait", shape=box];
      n48[label="CompleteTaskUseCase", full_path="$TMP/src/use_cases/task_use_cases.rs:23", sym_ty="Struct", shape=box];
      n44[label="CreateTaskUseCase", full_path="$TMP/src/use_cases/task_use_cases.rs:4", sym_ty="Struct", shape=box];
      n52[label="ListTasksUseCase", full_path="$TMP/src/use_cases/task_use_cases.rs:47", sym_ty="Struct", shape=box];
    }
  }
  n16 -> n8 [from="struct", to="field"];
  n8 -> n7 [from="struct", to="field"];
  n8 -> n6 [from="struct", to="field"];
  n33 -> n48 [from="bound", to="generic"];
  n33 -> n44 [from="bound", to="generic"];
  n33 -> n16 [from="trait", to="impl"];
  n33 -> n52 [from="bound", to="generic"];
  n39 -> n48 [from="bound", to="generic"];
  n39 -> n26 [from="trait", to="impl"];
  n39 -> n44 [from="bound", to="generic"];
  n39 -> n52 [from="bound", to="generic"];
  n3 -> n48 [from="user", to="used"];
  n3 -> n26 [from="user", to="used"];
  n3 -> n44 [from="user", to="used"];
  n3 -> n16 [from="user", to="used"];
  n3 -> n52 [from="user", to="used"];
  n3 -> n7 [from="user", to="used"];
}
