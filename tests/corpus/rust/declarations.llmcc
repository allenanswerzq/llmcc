================================================================================
Modules
================================================================================

--- file: src/main.rs ---
mod english;

mod english {}

mod english {
    mod greetings {}
    mod farewells {}
}

pub mod english;

--- expect:symbols ---
u0:1 | Module       | english   | english
u0:2 | Module       | english   | english
u0:3 | Module       | english   | english
u0:4 | Module       | greetings | english::greetings
u0:5 | Module       | farewells | english::farewells
u0:6 | Module       | english   | english [global]

================================================================================
Extern crate declarations
================================================================================

--- file: src/main.rs ---
extern crate std;
extern crate std as ruststd;
pub extern crate futures;


================================================================================
Function declarations
================================================================================

--- file: src/main.rs ---
fn main() {}

fn add(x: i32, y: i32) -> i32 {
    return x + y;
}

fn takes_slice(slice: &str) {
    println!("Got: {}", slice);
}

fn foo() -> [u32; 2] {
    return [1, 2];
}

fn foo() -> (u32, u16) {
    return (1, 2);
}

fn foo() {
    return
}

fn foo(x: impl FnOnce() -> result::Result<T, E>) {}

fn foo(#[attr] x: i32, #[attr] x: i64) {}

fn accumulate(self) -> Machine<{State::Accumulate}> {}

fn foo(bar: impl for<'a> Baz<Quux<'a>>) {}

--- expect:symbols ---
u0:1  | Function | main        | main
u0:2  | Function | add         | add
u0:3  | Variable | x           | add::x
u0:4  | Variable | y           | add::y
u0:5  | Function | takes_slice | takes_slice
u0:6  | Variable | slice       | takes_slice::slice
u0:7  | Function | foo         | foo
u0:8  | Function | foo         | foo
u0:9  | Function | foo         | foo
u0:10 | Function | foo         | foo
u0:11 | Variable | x           | foo::x
u0:12 | Function | foo         | foo
u0:13 | Variable | x           | foo::x
u0:14 | Variable | x           | foo::x
u0:15 | Function | accumulate  | accumulate
u0:16 | Function | foo         | foo
u0:17 | Variable | bar         | foo::bar


================================================================================
Const function declarations
================================================================================

--- file: src/main.rs ---
const fn main() {}

--- expect:symbols ---
u0:1  | Function | main        | main


================================================================================
Functions with abstract return types
================================================================================

--- file: src/main.rs ---
fn triples(a: impl B) -> impl Iterator<Item=(usize)> {
}

--- expect:symbols ---
u0:1 | Function | triples | triples
u0:2 | Variable | a       | triples::a


================================================================================
Impl with lifetimes first
================================================================================

--- file: src/main.rs ---
fn foo<'a>(x: impl 'a + Clone) {}

--- expect:symbols ---
u0:1 | Function | foo | foo
u0:2 | Variable | x   | foo::x


================================================================================
Functions with precise capture syntax
================================================================================

--- file: src/main.rs ---
fn capture<T>(&self) -> impl Iterator<Item = usize> + use<'_, T> {
}

--- expect:symbols ---
u0:1 | Function | capture | capture
u0:2 | Variable | self    | capture::self


================================================================================
Functions with empty precise capture syntax
================================================================================

--- file: src/main.rs ---
fn capture(&self) -> impl Iterator<Item = usize> + use<> {
}

--- expect:symbols ---
u0:1 | Function | capture | capture
u0:2 | Variable | self    | capture::self


================================================================================
Diverging functions
================================================================================

--- file: src/main.rs ---
fn aborts() -> ! {}

--- expect:symbols ---
u0:1 | Function | aborts | aborts


================================================================================
Extern function declarations
================================================================================

--- file: src/main.rs ---
extern "C" fn foo() {}
extern "C" fn printf(*const c_char, ...,) {}

pub unsafe extern "C" fn c_variadic_no_use(fmt: *const i8, mut ap: ...) -> i32 {
    // CHECK: call void @llvm.va_start
    vprintf(fmt, ap.as_va_list())
    // CHECK: call void @llvm.va_end
}

--- expect:symbols ---
u0:1 | Function | foo               | foo
u0:2 | Function | printf            | printf
u0:3 | Function | c_variadic_no_use | c_variadic_no_use [global]
u0:4 | Variable | fmt               | c_variadic_no_use::fmt


================================================================================
Use declarations
================================================================================

--- file: src/main.rs ---
use abc;
use phrases::japanese;
use sayings::english::greetings;
use sayings::english::greetings as en_greetings ;
use phrases::english::{greetings,farewells};
use sayings::japanese::farewells::*;
pub use self::greetings::hello;
use sayings::english::{self, greetings as en_greetings, farewells as en_farewells};
use three::{ dot::{one, four} };
use my::{ some::* };
use my::{*};
use ::*;

--- expect:symbols ---
<no-symbols>



================================================================================
Variable bindings
================================================================================

--- file: src/main.rs ---
let x;
let x = 42;
let x: i32;
let x: i8 = 42;
let mut x = 5;
let y: bool = false;
let bool: bool = false;
let u32: str = "";

--- expect:symbols ---
u0:1 | Variable | x    | x
u0:2 | Variable | x    | x
u0:3 | Variable | x    | x
u0:4 | Variable | x    | x
u0:5 | Variable | x    | x
u0:6 | Variable | y    | y
u0:7 | Variable | bool | bool
u0:8 | Variable | u32  | u32


================================================================================
Let-else Statements
================================================================================

--- file: src/main.rs ---
let Foo::Bar {
    texts,
    values,
} = foo().bar().await? else {
    return Err(index)
};

let Some(x) = y else {
    let None = z else {
        foo();
        break;
    };
    continue;
};

--- expect:symbols ---
u0:1 | Variable | texts  | texts
u0:2 | Variable | values | values
u0:3 | Variable | x      | x


================================================================================
Let declarations with if expressions as the value
================================================================================

--- file: src/main.rs ---
let a = if b {
    c
} else {
    d
};

--- expect:symbols ---
u0:1 | Variable | a | a


================================================================================
Let declarations with contextual keywords as names
================================================================================

--- file: src/main.rs ---
let default = 1;
let union = 2;

--- expect:symbols ---
u0:1 | Variable | default | default
u0:2 | Variable | union   | union


================================================================================
Structs
================================================================================

--- file: src/main.rs ---
struct Proton;
struct Electron {}
struct Person {pub name: String, pub age: u32}
struct Point {
  x: i32,

  #[attribute1]
  y: i32,
}
struct Color(pub i32, i32, i32);
struct Inches(i32);
struct Empty(pub ());

--- expect:symbols ---
u0:1  | Struct | Proton    | Proton
u0:2  | Struct | Electron  | Electron
u0:3  | Struct | Person    | Person
u0:4  | Field  | name      | Person::name
u0:5  | Field  | age       | Person::age
u0:6  | Struct | Point     | Point
u0:7  | Field  | x         | Point::x
u0:8  | Field  | y         | Point::y
u0:9  | Struct | Color     | Color
u0:10 | Struct | Inches    | Inches
u0:11 | Struct | Empty     | Empty


================================================================================
Unions
================================================================================

--- file: src/main.rs ---
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [__uint8_t; 16usize],
    pub __u6_addr16: [__uint16_t; 8usize],
    pub __u6_addr32: [__uint32_t; 4usize],
    _bindgen_union_align: [u32; 4usize],
}

--- expect:symbols ---
none


================================================================================
Generic structs
================================================================================

--- file: src/main.rs ---
struct A<B> {}
struct C<'a, 'b> {}
struct C<'a,> {}
struct D<const SIZE: usize> {}
struct E<#[attr] T> {}

--- expect:symbols ---
u0:1 | Struct | A | A
u0:2 | Struct | C | C
u0:3 | Struct | C | C
u0:4 | Struct | D | D
u0:5 | Struct | E | E


================================================================================
Enums
================================================================================

--- file: src/main.rs ---
pub enum Option<T> {
    None,
    Some(T),
}

pub enum Node<T: Item> {
    Internal {
        children: Vec<Tree<T>>,
        height: u16
    },
    #[attribute1]
    #[attribute2]
    Leaf {
        value: T
    }
}

--- expect:symbols ---
u0:1 | Enum     | Option   | Option [global]
u0:2 | Variant  | None     | Option::None [global]
u0:3 | Variant  | Some     | Option::Some [global]
u0:4 | Enum     | Node     | Node [global]
u0:5 | Variant  | Internal | Node::Internal [global]
u0:6 | Field    | children | Node::Internal::children [global]
u0:7 | Field    | height   | Node::Internal::height [global]
u0:8 | Variant  | Leaf     | Node::Leaf [global]
u0:9 | Field    | value    | Node::Leaf::value [global]


================================================================================
Enums with values specified
================================================================================

--- file: src/main.rs ---
pub enum c_style_enum {
    val1 = 1,
    val2 = 2
}

--- expect:symbols ---
u0:1 | Enum        | c_style_enum | c_style_enum [global]
u0:2 | EnumVariant | val1         | c_style_enum::val1 [global]
u0:3 | EnumVariant | val2         | c_style_enum::val2 [global]


================================================================================
Generic functions
================================================================================

--- file: src/main.rs ---
pub fn splice<T: Into<Text>>(&mut self, old_range: Range<usize>, new_text: T) {
}
pub fn uninit_array<const LEN: usize>() -> [Self; LEN] {}

--- expect:symbols ---
u0:1 | Function | splice         | splice [global]
u0:2 | Variable | self           | splice::self
u0:3 | Variable | old_range      | splice::old_range
u0:4 | Variable | new_text       | splice::new_text
u0:5 | Function | uninit_array   | uninit_array [global]


================================================================================
Functions with mutable parameters
================================================================================

--- file: src/main.rs ---
fn foo(mut x : u32) {
}

--- expect:symbols ---
u0:1 | Function | foo | foo
u0:2 | Variable | x   | foo::x


================================================================================
Functions with destructured parameters
================================================================================

--- file: src/main.rs ---
fn f1([x, y]: [u32; 2]) {}
fn f2(&x: &Y) {}
fn f3((x, y): (T, U)) {}

--- expect:symbols ---
u0:1 | Function | f1 | f1
u0:2 | Variable | x  | f1::x
u0:3 | Variable | y  | f1::y
u0:4 | Function | f2 | f2
u0:5 | Variable | x  | f2::x
u0:6 | Function | f3 | f3
u0:7 | Variable | x  | f3::x
u0:8 | Variable | y  | f3::y


================================================================================
Functions with custom types for self
================================================================================

--- file: src/main.rs ---
trait Callback {
    fn call(self: Box<Self>);
}

--- expect:symbols ---
u0:1 | Trait      | Callback | Callback
u0:2 | Function   | call     | Callback::call
u0:3 | Variable   | self     | Callback::call::self


================================================================================
Constant items
================================================================================

--- file: src/main.rs ---
const N: i32 = 5;

trait Foo {
    const X: u8;
}

--- expect:symbols ---
u0:1 | Const    | N   | N
u0:2 | Trait    | Foo | Foo
u0:3 | Const    | X   | Foo::X


================================================================================
Static items
================================================================================

--- file: src/main.rs ---
static N: i32 = 5;
static mut __progname: *mut ::c_char;

--- expect:symbols ---
u0:1 | Static | N          | N
u0:2 | Static | __progname | __progname


================================================================================
Static 'ref' items using lazy_static
================================================================================

--- file: src/main.rs ---
static ref ONE: usize = 0;

--- expect:symbols ---
u0:1 | Static | ONE | ONE


================================================================================
Type aliases
================================================================================

--- file: src/main.rs ---
type Inch = u64;
type Name<T> = Vec<T>;
type LazyResolve = impl (FnOnce() -> Capture) + Send + Sync + UnwindSafe;

--- expect:symbols ---
u0:1 | TypeAlias | Inch         | Inch
u0:2 | TypeAlias | Name         | Name
u0:3 | TypeAlias | LazyResolve  | LazyResolve


================================================================================
Type alias where clauses
================================================================================

--- file: src/main.rs ---
type Foo<T> where T: Copy = Box<T>;
type Assoc3 where = () where;

--- expect:symbols ---
u0:1 | TypeAlias | Foo     | Foo
u0:2 | TypeAlias | Assoc3  | Assoc3


================================================================================
Empty statements
================================================================================

--- file: src/main.rs ---
fn main() {
    ;
}

--- expect:symbols ---
u0:1 | Function | main | main


================================================================================
Attributes
================================================================================

--- file: src/main.rs ---
#[test]
fn test_foo() {}

#[derive(Debug)]
struct Baz;

#[derive(Debug, Eq,)]
struct Foo;

#[cfg(target_os = "macos")]
mod macos_only {}

#![allow(clippy::useless_transmute)]

#[clippy::cyclomatic_complexity = "100"]

--- expect:symbols ---
u0:1 | Function | test_foo | test_foo
u0:2 | Struct   | Baz      | Baz
u0:3 | Struct   | Foo      | Foo


================================================================================
Inner attributes
================================================================================

--- file: src/main.rs ---
mod macos_only {
  #![cfg(target_os = "macos")]
}

match ty {
    #![cfg_attr(all(test, exhaustive), deny(non_exhaustive_omitted_patterns))]
    syn::Type::Array(ty) => self.visit_type(&ty.elem),
}

--- expect:symbols ---
u0:1 | Module | macos_only | macos_only


================================================================================
Key-Value Attribute Expressions
================================================================================

--- file: src/main.rs ---
#[doc = include_str!("foo-doc.md")]
fn foo() {}

#[namespace = foo::bar]
fn baz() {}

--- expect:symbols ---
u0:1 | Function | foo | foo
u0:2 | Function | baz | baz


================================================================================
Attribute macros
================================================================================

--- file: src/main.rs ---
foo(#[attr(=> arbitrary tokens <=)] x, y);

foo(#[bar(some tokens are special in other contexts: $/';()*()+.)] x);

--- expect:symbols ---


================================================================================
Derive macro helper attributes
================================================================================

--- file: src/main.rs ---
// Example from https://github.com/dtolnay/thiserror/blob/21c26903e29cb92ba1a7ff11e82ae2001646b60d/README.md

use thiserror::Error;

#[derive(Error, Debug)]
pub enum Error {
    #[error("first letter must be lowercase but was {:?}", first_char(.0))]
    WrongCase(String),
    #[error("invalid index {idx}, expected at least {} and at most {}", .limits.lo, .limits.hi)]
    OutOfBounds { idx: usize, limits: Limits },
}

--- expect:symbols ---
u0:1 | UseDecl | Error | thiserror::Error
u0:2 | Enum   | Error | Error
u0:3 | Variant | WrongCase | Error::WrongCase
u0:4 | Field | | Error::WrongCase::0
u0:5 | Variant | OutOfBounds | Error::OutOfBounds
u0:6 | Field | idx | Error::OutOfBounds::idx
u0:7 | Field | limits | Error::OutOfBounds::limits


================================================================================
Attributes and Expressions
================================================================================

--- file: src/main.rs ---
fn foo() {
   bar(x,
       #[cfg(foo = "bar")]
       y);
   let z = [#[hello] 2, 7, 8];
   let t = (#[hello] 2, 7, 8);
}

--- expect:symbols ---
u0:1 | Function | foo | foo


================================================================================
Inherent Impls
================================================================================

--- file: src/main.rs ---
impl Person {
  const leg_count : u32 = 2;

  fn walk(self) {}
  fn walk_mut(mut self) {}
  fn talk(& self) {}
  fn talk_mut(&'a mut self) {}
}

impl Machine<{State::Init}> {}

--- expect:symbols ---
u0:1 | Impl     | Person | Person
u0:2 | Const    | leg_count | Person::leg_count
u0:3 | Method   | walk   | Person::walk
u0:4 | Variable | self   | Person::walk::self
u0:5 | Method   | walk_mut | Person::walk_mut
u0:6 | Variable | self   | Person::walk_mut::self
u0:7 | Method   | talk   | Person::talk
u0:8 | Variable | self   | Person::talk::self
u0:9 | Method   | talk_mut | Person::talk_mut
u0:10 | Variable | self   | Person::talk_mut::self
u0:11 | Impl     | Machine | Machine


================================================================================
Trait impls
================================================================================

--- file: src/main.rs ---
impl<'a> iter::Iterator for Self::Iter<'a> {
}

impl ConvertTo<i64> for i32 {
    fn convert(&self) -> i64 { *self as i64 }
}

--- expect:symbols ---
u0:1 | Impl | Iterator | iter::Iterator
u0:2 | Impl | ConvertTo | ConvertTo
u0:3 | Method | convert | ConvertTo::convert
u0:4 | Variable | self | ConvertTo::convert::self


================================================================================
Unsafe impls
================================================================================

--- file: src/main.rs ---
unsafe impl Foo {
}

--- expect:symbols ---
u0:1 | Impl | Foo | Foo


================================================================================
Disable automatically derived trait impls
================================================================================

--- file: src/main.rs ---
impl !Send for Foo {}

--- expect:symbols ---
u0:1 | Impl | Send | Send


================================================================================
Impl dyn with parentheses
================================================================================

--- file: src/main.rs ---
pub unsafe trait Trait {}

unsafe impl Trait for dyn (::std::any::Any) + Send { }

--- expect:symbols ---
u0:1 | Trait | Trait | Trait
u0:2 | Impl  | Trait | Trait


================================================================================
Trait impl signature
================================================================================

--- file: src/main.rs ---
impl<K: Debug + Ord> Debug for OccupiedError<K>;
impl<K: Debug + Ord> Display for OccupiedError<K>;

--- expect:symbols ---
u0:1 | Impl | Debug   | OccupiedError
u0:2 | Impl | Display | OccupiedError


================================================================================
Impls with default functions
================================================================================

--- file: src/main.rs ---
impl Foo {
  const default fn bar() -> i32 {
    // Make 'default' still works as an identifier
    default.bar();
  }
}

--- expect:symbols ---
u0:1 | Impl     | Foo | Foo
u0:2 | Method   | bar | Foo::bar


================================================================================
Trait declarations
================================================================================

--- file: src/main.rs ---
pub trait Item: Clone + Eq + fmt::Debug {
    fn summarize(&self) -> Self::Summary;
}

unsafe trait Foo { }

--- expect:symbols ---
u0:1 | Trait  | Item      | Item
u0:2 | Method | summarize | Item::summarize
u0:3 | Trait  | Foo       | Foo


================================================================================
Trait declarations with optional type parameters
================================================================================

--- file: src/main.rs ---
trait Add<RHS=Self> {
    type Output;
    fn add(self, rhs: RHS) -> Self::Output;
}

--- expect:symbols ---
u0:1 | Trait     | Add    | Add
u0:2 | AssocType | Output | Add::Output
u0:3 | Method    | add    | Add::add
u0:4 | Variable  | self   | Add::add::self
u0:5 | Variable  | rhs    | Add::add::rhs


================================================================================
Unsized types in trait bounds
================================================================================

--- file: src/main.rs ---
trait Foo<T: ?Sized> {
}

fn univariant(this: &impl ?Sized, that: &(impl LayoutCalculator + ?Sized)) {}

--- expect:symbols ---
u0:1 | Trait    | Foo        | Foo
u0:2 | Function | univariant | univariant
u0:3 | Variable | this       | univariant::this
u0:4 | Variable | that       | univariant::that


================================================================================
Trait bounds in type arguments in trait
================================================================================

--- file: src/main.rs ---
impl<T: AstDeref<Target: HasNodeId>> HasNodeId for T {}

--- expect:symbols ---
u0:1 | Impl | HasNodeId | HasNodeId


================================================================================
Macro invocations inside trait declarations
================================================================================

--- file: src/main.rs ---
pub trait A: B + C + D {
    private_decl!{}
    fn f(&self);
}

--- expect:symbols ---
u0:1 | Trait  | A | A
u0:2 | Method | f | A::f


================================================================================
Associated Types
================================================================================

--- file: src/main.rs ---
pub trait Graph {
    type N: fmt::Display;
    type E;
}

--- expect:symbols ---
u0:1 | Trait     | Graph | Graph
u0:2 | AssocType | N     | Graph::N
u0:3 | AssocType | E     | Graph::E


================================================================================
Associated Type Definitions
================================================================================

--- file: src/main.rs ---
impl Trait for T {
    type Associated = T where 'static: 'static;
}

--- expect:symbols ---
u0:1 | Impl      | Trait | Trait
u0:2 | AssocType | Associated | Trait::Associated


================================================================================
Generic Associated Types
================================================================================

--- file: src/main.rs ---
pub trait Database {
    type F<'a, D>: Future<Output = D> + 'a;
}

impl Database for Foo {
    type F<'a, D> = DatabaseFuture<'a, D>;
}

fn use_database1<D: Database<F<'a, TD> = F>>() {}

fn use_database2<D>()
where
    D: Database<F<'a, TD> = F>,
{}

--- expect:symbols ---
u0:1 | Trait     | Database | Database
u0:2 | AssocType | F        | Database::F
u0:3 | Impl      | Database | Database
u0:4 | AssocType | F        | Database::F
u0:5 | Function  | use_database1 | use_database1
u0:6 | Function  | use_database2 | use_database2


================================================================================
Higher-ranked types
================================================================================

--- file: src/main.rs ---
trait T: for<'a> AddAssign<&'a usize> {
}

type FnObject<'b> = dyn for<'a> FnLike<&'a isize, &'a isize> + 'b;

--- expect:symbols ---
u0:1 | Trait     | T       | T
u0:2 | TypeAlias | FnObject | FnObject


================================================================================
Visibility modifiers
================================================================================

--- file: src/main.rs ---
pub fn a() {}
pub(super) fn b() {}
pub(self) fn c() {}
pub(crate) fn c() {}
pub(in crate::d) fn e() {}

--- expect:symbols ---
u0:1 | Function | a | a
u0:2 | Function | b | b
u0:3 | Function | c | c
u0:4 | Function | c | c
u0:5 | Function | e | e


================================================================================
Function parameter names that match built-in type names
================================================================================

--- file: src/main.rs ---
fn foo(str: *const c_char) {}
fn bar(bool: bool) {}

--- expect:symbols ---
u0:1 | Function | foo  | foo
u0:2 | Variable | str  | foo::str
u0:3 | Function | bar  | bar
u0:4 | Variable | bool | bar::bool


================================================================================
Where clauses
================================================================================

--- file: src/main.rs ---
fn walk<F>(&self, it: &mut F) -> bool
    where F: FnMut(&Pat) -> bool
{
  return false
}

impl<'a, T: 'a + Item> Iterator for Iter<'a, T> where Self: 'a {
}

impl<T> A for B<T>
    where C<T>: D,
          T: 'c,
          'c: 'b,
{
}

impl<'a, E> Read
where &'a E: Read,
{
}

impl<T> A for B<T> where (T, T, T): C, {}

impl<T> A for B<T>
    where for<'a> D<T>: E<'a>,
{
}

pub trait A<B> where B: C,
{
}

fn foo<A>() where A: B + As<f64>, f64: As<A> {}

impl<A> Default for B<A> where *mut A: C + D {}

--- expect:symbols ---
u0:1 | Function | walk      | walk
u0:2 | Variable | self      | walk::self
u0:3 | Variable | it        | walk::it
u0:4 | Impl     | Iterator  | Iterator
u0:5 | Impl     | Read      | Read
u0:6 | Impl     | A         | A
u0:7 | Trait    | A         | A
u0:8 | Function | foo       | foo


================================================================================
External Modules
================================================================================

--- file: src/main.rs ---
extern {
  pub fn napi_module_register(mod_: *mut napi_module);
}

extern "C" {}

unsafe extern "C" {}

--- expect:symbols ---
u0:1 | Function | napi_module_register | napi_module_register
u0:2 | Variable | mod_                  | napi_module_register::mod_


================================================================================
Crate visibility
================================================================================

--- file: src/main.rs ---
crate mod foo;
crate struct Foo(crate crate::Bar);
crate fn foo() { }
crate const X: u32 = 0;

--- expect:symbols ---
u0:1 | Module   | foo | foo
u0:2 | Struct   | Foo | Foo
u0:3 | Function | foo | foo
u0:4 | Const    | X   | X


================================================================================
Reserved keywords in path
================================================================================

--- file: src/main.rs ---
struct A {
  a: default::B,
  b: union::C,
}

--- expect:symbols ---
u0:1 | Struct | A | A
u0:2 | Field  | a | A::a
u0:3 | Field  | b | A::b


================================================================================
Array Constraint in Where Clause
================================================================================

--- file: src/main.rs ---
fn foo<D>(val: D)
where
    [u8; 32]: From<D>,

{}

--- expect:symbols ---
u0:1 | Function | foo | foo
u0:2 | Variable | val | foo::val


================================================================================
Const generics with default
================================================================================

--- file: src/main.rs ---
pub struct Loaf<T: Sized, const N: usize = 1>([T; N]);

--- expect:symbols ---
u0:1 | Struct | Loaf | Loaf


